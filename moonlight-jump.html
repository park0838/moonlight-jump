<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- 🛡️ SECURITY: Content Security Policy -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: blob:; connect-src 'self'; frame-ancestors 'none'; base-uri 'self'; form-action 'self';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    
    <title>Moonlight Jump</title>
    <!-- 🛡️ SECURITY: CDN resources with SRI integrity hashes -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js" 
            integrity="sha384-OqQP3UcU7efkEYDRjGmQou2uEvzGFGRtwdYXTjnupeB9cWogSgQ4BOhyklFBYbBR" 
            crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js" 
            integrity="sha384-oHYQNeDBTZNj6KnIfJMAzcEn2OTbeMKKXFeEwU6T+pH0oS1yTIzEBaW6BXmCtvs2" 
            crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" 
          rel="stylesheet" crossorigin="anonymous">
    <style>
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff6b6b;
            --accent-color: #4ecdc4;
            --bg-dark: #0a0a0f;
            --bg-darker: #060609;
            --text-light: #ffffff;
            --text-muted: #a0a0a0;
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --success-color: #00ff88;
            --warning-color: #ffaa00;
            --danger-color: #ff4757;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(ellipse at center, var(--bg-dark) 0%, var(--bg-darker) 100%);
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: var(--text-light);
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Performance optimized particles background */
        #particles-js {
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0.6;
            will-change: transform;
        }

        /* Main game container */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            z-index: 2;
        }

        /* Enhanced UI with glassmorphism */
        #ui {
            position: fixed;
            top: clamp(10px, 2vh, 20px);
            left: clamp(10px, 2vw, 20px);
            right: clamp(10px, 2vw, 20px);
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
            pointer-events: none;
        }

        .ui-element {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: clamp(8px, 1.5vh, 16px) clamp(12px, 3vw, 20px);
            font-weight: 600;
            font-size: clamp(0.9rem, 2.5vw, 1.2rem);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .ui-element:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        /* Enhanced height progress bar */
        #height-progress {
            position: fixed;
            left: 50%;
            top: clamp(10px, 2vh, 20px);
            transform: translateX(-50%);
            width: clamp(150px, 40vw, 250px);
            height: 8px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            overflow: hidden;
            pointer-events: none;
        }

        #height-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            border-radius: 8px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
            position: relative;
        }

        #height-fill::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 30px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3));
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-30px); }
            100% { transform: translateX(100px); }
        }

        /* Screen transitions with improved UX */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(30px);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            opacity: 1;
            visibility: visible;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 2rem;
        }

        .screen.hidden {
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
        }

        .title {
            font-size: clamp(2.5rem, 8vw, 4rem);
            font-weight: 700;
            margin-bottom: clamp(1rem, 4vh, 2rem);
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 3s ease-in-out infinite alternate;
            letter-spacing: -0.02em;
        }

        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.3)); }
            to { filter: drop-shadow(0 0 40px rgba(0, 212, 255, 0.6)); }
        }

        .subtitle {
            font-size: clamp(0.9rem, 3vw, 1.1rem);
            color: var(--text-muted);
            margin-bottom: clamp(2rem, 6vh, 3rem);
            font-weight: 300;
            line-height: 1.6;
            max-width: 500px;
        }

        .instructions {
            margin-bottom: clamp(2rem, 6vh, 3rem);
            line-height: 1.8;
            font-size: clamp(0.95rem, 3vw, 1.1rem);
            color: var(--text-muted);
            max-width: 400px;
        }

        .instructions p {
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .key-hint {
            background: var(--glass-bg);
            padding: 0.3rem 0.8rem;
            border-radius: 6px;
            border: 1px solid var(--glass-border);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            font-weight: 500;
        }

        /* Enhanced buttons with better accessibility */
        .game-button {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            border: none;
            color: var(--text-light);
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            font-weight: 600;
            padding: clamp(12px, 3vh, 18px) clamp(24px, 6vw, 36px);
            margin: 0.5rem;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            position: relative;
            overflow: hidden;
            min-width: 140px;
        }

        .game-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 48px rgba(0, 212, 255, 0.4);
            filter: brightness(1.1);
        }

        .game-button:hover::before {
            left: 100%;
        }

        .game-button:active {
            transform: translateY(0);
            transition: transform 0.1s;
        }

        .game-button:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.5);
        }

        /* Enhanced player with smooth animations */
        #player {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, var(--text-light), var(--primary-color));
            box-shadow: 
                0 0 20px rgba(0, 212, 255, 0.6),
                inset 2px 2px 4px rgba(255, 255, 255, 0.3);
            z-index: 999;
            will-change: transform;
            transition: filter 0.2s ease;
        }

        #player.jumping {
            animation: playerJump 0.3s ease-out;
        }

        @keyframes playerJump {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.3) drop-shadow(0 0 15px rgba(0, 212, 255, 0.8)); }
            100% { filter: brightness(1); }
        }

        /* Enhanced platforms with better visual hierarchy */
        .platform {
            position: absolute;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 500;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            color: var(--text-muted);
            z-index: 5;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            will-change: transform;
        }

        .platform.spring {
            color: var(--success-color);
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
            animation: springPulse 2s ease-in-out infinite;
        }

        @keyframes springPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.2); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 136, 0.4); }
        }

        /* Particle effects with GPU acceleration */
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 800;
            border-radius: 50%;
            will-change: transform, opacity;
        }

        .jump-particle {
            width: 3px;
            height: 3px;
            background: var(--primary-color);
            box-shadow: 0 0 6px var(--primary-color);
            animation: jumpParticleAnim 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes jumpParticleAnim {
            0% { 
                opacity: 1; 
                transform: scale(1) translateY(0); 
            }
            100% { 
                opacity: 0; 
                transform: scale(0.3) translateY(-60px); 
            }
        }

        .land-particle {
            width: 4px;
            height: 4px;
            background: var(--accent-color);
            box-shadow: 0 0 8px var(--accent-color);
            animation: landParticleAnim 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes landParticleAnim {
            0% { 
                opacity: 1; 
                transform: scale(1) translateX(0) translateY(0); 
            }
            100% { 
                opacity: 0; 
                transform: scale(0.2) translateX(var(--spread, 40px)) translateY(10px); 
            }
        }

        /* Loading screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--bg-darker);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(0, 212, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive design improvements */
        @media (max-width: 768px) {
            #ui {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
            
            .ui-element {
                font-size: clamp(0.8rem, 4vw, 1rem);
                padding: clamp(6px, 2vh, 12px) clamp(10px, 4vw, 16px);
            }

            #player {
                width: 20px;
                height: 20px;
            }
        }

        @media (max-height: 500px) {
            .title {
                font-size: clamp(2rem, 6vh, 3rem);
                margin-bottom: 1rem;
            }
            
            .instructions, .subtitle {
                margin-bottom: 1.5rem;
            }
        }

        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Focus indicators for keyboard navigation */
        .game-button:focus-visible,
        .ui-element:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <!-- Loading screen -->
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
    </div>

    <!-- Background particles -->
    <div id="particles-js"></div>
    
    <div id="game-container">
        <!-- Enhanced UI -->
        <div id="ui">
            <div class="ui-element" id="score">
                <span id="height">0m</span>
            </div>
            <div class="ui-element" id="best-score">
                최고: <span id="best">0m</span>
            </div>
        </div>

        <!-- Progress bar -->
        <div id="height-progress">
            <div id="height-fill"></div>
        </div>

        <!-- Game elements -->
        <div id="player"></div>
        <div id="platforms"></div>
        <div id="particles-container"></div>

        <!-- Menu Screen -->
        <div id="menu-screen" class="screen">
            <div class="title">MOONLIGHT JUMP</div>
            <div class="subtitle">중력을 거슬러 달까지 올라가세요</div>
            <div class="instructions">
                <p><span class="key-hint">Spacebar</span> Jump</p>
                <p><span class="key-hint">A</span> <span class="key-hint">D</span> 이동</p>
                <p><span style="color: var(--text-muted);">Mobile: Touch to jump</span></p>
            </div>
            <button id="start-button" class="game-button" role="button" aria-label="Start Game">Start</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen hidden">
            <div class="title" style="background: linear-gradient(135deg, var(--danger-color), var(--warning-color)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Game Over</div>
            <div id="final-score" style="font-size: clamp(1.5rem, 5vw, 2rem); margin-bottom: clamp(1rem, 3vh, 1.5rem); font-weight: 600;">
                높이: <span>0m</span>
            </div>
            <div id="new-record" class="hidden" style="color: var(--success-color); font-size: clamp(1.2rem, 4vw, 1.5rem); margin-bottom: clamp(1rem, 3vh, 1.5rem); font-weight: 600;">
                🎉 신기록!
            </div>
            <div style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;">
                <button id="restart-button" class="game-button" role="button" aria-label="Restart Game">Restart</button>
                <button id="menu-button" class="game-button" role="button" aria-label="메뉴로 돌아가기">메뉴</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced error handling and performance monitoring
        class GameError extends Error {
            constructor(message, context = {}) {
                super(message);
                this.context = context;
                this.name = 'GameError';
            }
        }

        // Performance monitor
        class PerformanceMonitor {
            constructor() {
                this.fps = 60;
                this.frameTime = 0;
                this.lastFrameTime = performance.now();
            }

            update() {
                const currentTime = performance.now();
                this.frameTime = currentTime - this.lastFrameTime;
                this.fps = Math.round(1000 / this.frameTime);
                this.lastFrameTime = currentTime;
                
                // Auto-adjust quality based on performance
                if (this.fps < 30) {
                    this.optimizePerformance();
                }
            }

            optimizePerformance() {
                // Reduce particle count on low performance
                const particlesContainer = document.getElementById('particles-container');
                if (particlesContainer && particlesContainer.children.length > 20) {
                    Array.from(particlesContainer.children).slice(0, 10).forEach(child => child.remove());
                }
            }
        }

        const performanceMonitor = new PerformanceMonitor();

        // Enhanced game configuration with responsive values
        const GAME_CONFIG = {
            jumpPower: 15,
            horizontalSpeed: 2.1,
            platformGap: Math.max(100, window.innerHeight * 0.15),
            gameWidth: window.innerWidth,
            gameHeight: window.innerHeight,
            maxHeight: 15000,
            particleLimit: 30
        };

        // Matter.js modules
        const { Engine, World, Bodies, Body, Events, Runner } = Matter;

        // Physics engine
        let engine, world, runner;
        let playerBody;
        let platforms = [];
        let gameLoopId = null;

        // 🚀 PERFORMANCE: Enhanced game state with race condition protection
        let gameState = {
            currentState: 'loading',
            camera: { y: 0 },
            score: { height: 0, best: parseInt(localStorage.getItem('quantum-jump-best') || '0') },
            keys: {},
            canJump: false,
            isGameRunning: false,
            touchStartY: 0,
            lastJumpTime: 0,
            particleCount: 0,
            // 🛡️ Race condition protection
            collisionCooldowns: new Map(),
            physicsLocked: false
        };

        // DOM elements with null checks
        const elements = {
            loading: document.getElementById('loading'),
            player: document.getElementById('player'),
            platformsContainer: document.getElementById('platforms'),
            particlesContainer: document.getElementById('particles-container'),
            heightScore: document.getElementById('height'),
            bestScore: document.getElementById('best'),
            heightFill: document.getElementById('height-fill'),
            menuScreen: document.getElementById('menu-screen'),
            gameOverScreen: document.getElementById('game-over-screen'),
            finalScore: document.querySelector('#final-score span'),
            newRecord: document.getElementById('new-record'),
            startButton: document.getElementById('start-button'),
            restartButton: document.getElementById('restart-button'),
            menuButton: document.getElementById('menu-button')
        };

        // Enhanced Sound System with user interaction handling
        class SoundEngine {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.isInitialized = false;
                this.soundQueue = [];
            }

            async init() {
                if (this.isInitialized) return;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = 0.2;
                    this.isInitialized = true;
                    
                    // Process queued sounds
                    this.soundQueue.forEach(sound => sound());
                    this.soundQueue = [];
                } catch (e) {
                    console.warn('Audio initialization failed:', e);
                }
            }

            async resumeContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            playTone(frequency, duration, type = 'sine', envelope = null) {
                if (!this.isInitialized) {
                    this.soundQueue.push(() => this.playTone(frequency, duration, type, envelope));
                    return;
                }

                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.masterGain);

                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    oscillator.type = type;

                    if (envelope) {
                        gainNode.gain.setValueAtTime(envelope.attack, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(envelope.decay, this.audioContext.currentTime + duration * 0.3);
                        gainNode.gain.exponentialRampToValueAtTime(envelope.sustain, this.audioContext.currentTime + duration * 0.7);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    } else {
                        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    }

                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                } catch (e) {
                    console.warn('Sound playback failed:', e);
                }
            }

            jump() {
                this.playTone(440, 0.15, 'square', { attack: 0.3, decay: 0.2, sustain: 0.1 });
                setTimeout(() => this.playTone(660, 0.08, 'sine'), 30);
            }

            land() {
                this.playTone(220, 0.12, 'triangle', { attack: 0.4, decay: 0.2, sustain: 0.1 });
            }

            spring() {
                this.playTone(880, 0.25, 'sawtooth', { attack: 0.6, decay: 0.3, sustain: 0.2 });
            }

            gameOver() {
                this.playTone(200, 0.4, 'triangle');
                setTimeout(() => this.playTone(150, 0.4, 'triangle'), 150);
                setTimeout(() => this.playTone(100, 0.8, 'triangle'), 300);
            }

            achievement() {
                [523, 659, 784, 1047].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.2, 'sine'), i * 100);
                });
            }
        }

        const soundEngine = new SoundEngine();

        // 🚀 PERFORMANCE: Enhanced particle system with object pooling
        class ParticlePool {
            constructor(initialSize = 50) {
                this.pool = [];
                this.active = [];
                this.maxPoolSize = 100;
                this.particleLimit = GAME_CONFIG.particleLimit;
                
                // Pre-allocate particle DOM elements
                this.initializePool(initialSize);
            }
            
            initializePool(size) {
                for (let i = 0; i < size; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.position = 'absolute';
                    particle.style.pointerEvents = 'none';
                    particle.style.zIndex = '800';
                    particle.style.borderRadius = '50%';
                    particle.style.willChange = 'transform, opacity';
                    particle.style.display = 'none';
                    this.pool.push(particle);
                }
            }
            
            acquire() {
                if (this.active.length >= this.particleLimit) {
                    return this.release(this.active[0]);
                }
                
                let particle;
                if (this.pool.length > 0) {
                    particle = this.pool.pop();
                } else {
                    particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.position = 'absolute';
                    particle.style.pointerEvents = 'none';
                    particle.style.zIndex = '800';
                    particle.style.borderRadius = '50%';
                    particle.style.willChange = 'transform, opacity';
                }
                
                particle.style.display = 'block';
                this.active.push(particle);
                return particle;
            }
            
            release(particle) {
                if (!particle) return null;
                
                const index = this.active.indexOf(particle);
                if (index > -1) {
                    this.active.splice(index, 1);
                    
                    particle.style.display = 'none';
                    particle.style.animation = '';
                    particle.style.transform = '';
                    particle.style.opacity = '1';
                    particle.className = 'particle';
                    
                    if (this.pool.length < this.maxPoolSize) {
                        this.pool.push(particle);
                    }
                    
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }
                return particle;
            }
            
            cleanup() {
                this.active = this.active.filter(particle => {
                    const isExpired = !particle.parentNode || particle.style.display === 'none';
                    if (isExpired) {
                        this.release(particle);
                        return false;
                    }
                    return true;
                });
            }
            
            clear() {
                [...this.active].forEach(particle => this.release(particle));
                this.active.length = 0;
            }
        }
        
        // Global particle pool instance
        const particlePool = new ParticlePool();
        
        // Enhanced Particle System with object pooling
        class ParticleSystem {
            static createJumpParticles(x, y) {
                const particleCount = Math.min(6, GAME_CONFIG.particleLimit - particlePool.active.length);
                if (particleCount <= 0) return;
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = particlePool.acquire();
                    particle.className = 'particle jump-particle';
                    particle.style.left = (x + Math.random() * 16 - 8) + 'px';
                    particle.style.top = (y + Math.random() * 8 - 4) + 'px';
                    elements.particlesContainer.appendChild(particle);
                    
                    // 🚀 PERFORMANCE: Use pool cleanup instead of setTimeout
                    setTimeout(() => particlePool.release(particle), 600);
                }
            }

            static createLandParticles(x, y) {
                const particleCount = Math.min(8, GAME_CONFIG.particleLimit - particlePool.active.length);
                if (particleCount <= 0) return;
                
                for (let i = 0; i < particleCount; i++) {
                    const particle = particlePool.acquire();
                    particle.className = 'particle land-particle';
                    const spread = (Math.random() - 0.5) * 50;
                    particle.style.setProperty('--spread', spread + 'px');
                    particle.style.left = (x + Math.random() * 16 - 8) + 'px';
                    particle.style.top = (y + 10) + 'px';
                    elements.particlesContainer.appendChild(particle);
                    gameState.particleCount++;
                    
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                            gameState.particleCount--;
                        }
                    }, 400);
                }
            }

            static createSpringParticles(x, y) {
                if (gameState.particleCount > GAME_CONFIG.particleLimit) return;
                
                const particleCount = Math.min(10, GAME_CONFIG.particleLimit - gameState.particleCount);
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.width = '2px';
                    particle.style.height = '2px';
                    particle.style.background = 'var(--success-color)';
                    particle.style.borderRadius = '50%';
                    particle.style.left = (x + Math.random() * 30 - 15) + 'px';
                    particle.style.top = (y + Math.random() * 8 - 4) + 'px';
                    particle.style.boxShadow = '0 0 8px var(--success-color)';
                    particle.style.animation = 'jumpParticleAnim 0.7s ease-out forwards';
                    elements.particlesContainer.appendChild(particle);
                    gameState.particleCount++;
                    
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                            gameState.particleCount--;
                        }
                    }, 700);
                }
            }
        }

        // Initialize physics engine with error handling
        function initPhysics() {
            try {
                engine = Engine.create();
                world = engine.world;
                runner = Runner.create();
                
                engine.world.gravity.y = 1;
                engine.world.gravity.x = 0;
                
                // Enhanced collision detection
                Events.on(engine, 'collisionStart', function(event) {
                    event.pairs.forEach(pair => {
                        const { bodyA, bodyB } = pair;
                        
                        if ((bodyA.label === 'player' && bodyB.label === 'ground-sensor') ||
                            (bodyB.label === 'player' && bodyA.label === 'ground-sensor')) {
                            gameState.canJump = true;
                            soundEngine.land();
                            if (playerBody) {
                                ParticleSystem.createLandParticles(playerBody.position.x, playerBody.position.y);
                            }
                        }
                        
                        // Enhanced spring platform
                        if ((bodyA.label === 'player' && bodyB.label === 'spring') ||
                            (bodyB.label === 'player' && bodyA.label === 'spring')) {
                            setTimeout(() => {
                                if (playerBody && gameState.canJump) {
                                    Body.setVelocity(playerBody, { x: playerBody.velocity.x, y: -20 });
                                    soundEngine.spring();
                                    ParticleSystem.createSpringParticles(playerBody.position.x, playerBody.position.y);
                                }
                            }, 80);
                        }
                    });
                });
                
                Events.on(engine, 'collisionEnd', function(event) {
                    event.pairs.forEach(pair => {
                        const { bodyA, bodyB } = pair;
                        
                        if ((bodyA.label === 'player' && bodyB.label === 'ground-sensor') ||
                            (bodyB.label === 'player' && bodyA.label === 'ground-sensor')) {
                            setTimeout(() => { gameState.canJump = false; }, 20);
                        }
                    });
                });

                return true;
            } catch (error) {
                throw new GameError('Physics initialization failed', { error });
            }
        }

        // Create player with enhanced properties
        function createPlayer() {
            try {
                const startX = GAME_CONFIG.gameWidth / 2;
                const startY = GAME_CONFIG.gameHeight - 150;
                
                playerBody = Bodies.circle(startX, startY, 12, {
                    restitution: 0.05,
                    friction: 0.3,
                    frictionAir: 0.02,
                    label: 'player'
                });
                
                World.add(world, playerBody);
                return true;
            } catch (error) {
                throw new GameError('Player creation failed', { error });
            }
        }

        // Enhanced platform creation with better distribution
        function createPlatform(x, y, type, width) {
            try {
                const platformWidth = width * 18;
                const platformHeight = 16;
                
                // Physics body
                const platformBody = Bodies.rectangle(x + platformWidth/2, y + platformHeight/2, platformWidth, platformHeight, {
                    isStatic: true,
                    label: type === 'spring' ? 'spring' : 'platform'
                });
                
                // Ground sensor
                const sensorBody = Bodies.rectangle(x + platformWidth/2, y - 4, platformWidth, 8, {
                    isStatic: true,
                    isSensor: true,
                    label: 'ground-sensor'
                });
                
                World.add(world, [platformBody, sensorBody]);
                
                // Visual element
                const element = document.createElement('div');
                element.className = `platform ${type}`;
                element.textContent = (type === 'spring' ? '↑' : '═').repeat(width);
                element.style.left = x + 'px';
                element.style.top = y + 'px';
                element.style.width = platformWidth + 'px';
                element.style.height = platformHeight + 'px';
                
                elements.platformsContainer.appendChild(element);
                platforms.push({ element, body: platformBody, sensor: sensorBody, x, y, type });
                
                return true;
            } catch (error) {
                console.warn('Platform creation failed:', error);
                return false;
            }
        }

        // Enhanced platform generation with better spacing
        function generateInitialPlatforms() {
            try {
                // Starting platform
                createPlatform(GAME_CONFIG.gameWidth / 2 - 80, GAME_CONFIG.gameHeight - 80, 'normal', 8);
                
                // Generate platforms with intelligent distribution
                for (let i = 1; i < 30; i++) {
                    const x = Math.random() * (GAME_CONFIG.gameWidth - 180) + 90;
                    const y = GAME_CONFIG.gameHeight - 80 - (i * GAME_CONFIG.platformGap);
                    
                    let type = 'normal';
                    if (i % 12 === 0) type = 'spring'; // Every 12th platform
                    else if (i > 15 && Math.random() < 0.12) type = 'spring'; // 12% chance after level 15
                    
                    const width = Math.random() > 0.3 ? 5 : Math.random() > 0.7 ? 6 : 4;
                    createPlatform(x, y, type, width);
                }
                
                return true;
            } catch (error) {
                throw new GameError('Platform generation failed', { error });
            }
        }

        // Enhanced jump function with cooldown
        function jump() {
            const currentTime = Date.now();
            if (gameState.canJump && playerBody && currentTime - gameState.lastJumpTime > 100) {
                Body.setVelocity(playerBody, { x: playerBody.velocity.x, y: -GAME_CONFIG.jumpPower });
                gameState.canJump = false;
                gameState.lastJumpTime = currentTime;
                
                soundEngine.jump();
                ParticleSystem.createJumpParticles(playerBody.position.x, playerBody.position.y);
                
                // Visual feedback
                elements.player.classList.add('jumping');
                setTimeout(() => elements.player.classList.remove('jumping'), 300);
            }
        }

        // Enhanced movement with better physics
        function updateMovement() {
            if (!playerBody) return;
            
            let forceX = 0;
            if (gameState.keys['ArrowLeft'] || gameState.keys['KeyA']) forceX = -0.0035;
            if (gameState.keys['ArrowRight'] || gameState.keys['KeyD']) forceX = 0.0035;
            
            if (forceX !== 0) {
                Body.applyForce(playerBody, playerBody.position, { x: forceX, y: 0 });
            }
            
            // Enhanced velocity limits with screen bounds
            const maxVelocity = 2.1;
            if (Math.abs(playerBody.velocity.x) > maxVelocity) {
                Body.setVelocity(playerBody, { 
                    x: Math.sign(playerBody.velocity.x) * maxVelocity, 
                    y: playerBody.velocity.y 
                });
            }
            
            // Keep player within screen bounds
            if (playerBody.position.x < 12) {
                Body.setPosition(playerBody, { x: 12, y: playerBody.position.y });
            } else if (playerBody.position.x > GAME_CONFIG.gameWidth - 12) {
                Body.setPosition(playerBody, { x: GAME_CONFIG.gameWidth - 12, y: playerBody.position.y });
            }
        }

        // Enhanced camera with smoother movement
        function updateCamera() {
            if (!playerBody) return;
            
            const targetY = Math.min(0, GAME_CONFIG.gameHeight / 2 - playerBody.position.y);
            gameState.camera.y += (targetY - gameState.camera.y) * 0.08;
            
            // Update player visual position
            elements.player.style.left = (playerBody.position.x - 12) + 'px';
            elements.player.style.top = (playerBody.position.y - 12 + gameState.camera.y) + 'px';
            
            // Update platforms position
            platforms.forEach(platform => {
                platform.element.style.transform = `translateY(${gameState.camera.y}px)`;
            });
            
            // Update particles container
            elements.particlesContainer.style.transform = `translateY(${gameState.camera.y}px)`;
        }

        // Enhanced score system with achievements
        function updateScore() {
            if (!playerBody) return;
            
            const height = Math.max(0, Math.floor((GAME_CONFIG.gameHeight - playerBody.position.y) / 8));
            if (height > gameState.score.height) {
                const previousHeight = gameState.score.height;
                gameState.score.height = height;
                elements.heightScore.textContent = height + 'm';
                
                // Update progress bar
                const progress = Math.min(100, (height / GAME_CONFIG.maxHeight) * 100);
                elements.heightFill.style.width = progress + '%';
                
                // Achievement milestones
                const milestones = [500, 1000, 2000, 5000, 10000];
                const reachedMilestone = milestones.find(milestone => 
                    previousHeight < milestone && height >= milestone
                );
                
                if (reachedMilestone) {
                    soundEngine.achievement();
                }
                
                // Dynamic background based on height
                const hue = Math.min(280, 240 - height / 100);
                const lightness = Math.max(3, 8 - height / 2000);
                document.body.style.background = `radial-gradient(ellipse at center, 
                    hsl(${hue}, 60%, ${lightness}%) 0%, 
                    hsl(${hue - 20}, 80%, ${lightness - 2}%) 100%)`;
            }
            
            // Enhanced game over detection
            if (playerBody.position.y > GAME_CONFIG.gameHeight + 200) {
                gameOver();
            }
        }

        // Enhanced game over with better UX
        function gameOver() {
            gameState.isGameRunning = false;
            gameState.currentState = 'gameOver';
            
            if (runner) Runner.stop(runner);
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            soundEngine.gameOver();
            
            elements.finalScore.textContent = gameState.score.height + 'm';
            
            if (gameState.score.height > gameState.score.best) {
                gameState.score.best = gameState.score.height;
                localStorage.setItem('quantum-jump-best', gameState.score.best);
                elements.newRecord.classList.remove('hidden');
                elements.bestScore.textContent = 'Best: ' + gameState.score.best + 'm';
            } else {
                elements.newRecord.classList.add('hidden');
            }
            
            setTimeout(() => {
                elements.gameOverScreen.classList.remove('hidden');
            }, 500);
        }

        // Enhanced game reset
        function resetGame() {
            try {
                if (world) {
                    World.clear(world);
                    Engine.clear(engine);
                }
                
                gameState.camera.y = 0;
                gameState.score.height = 0;
                gameState.canJump = false;
                gameState.lastJumpTime = 0;
                gameState.particleCount = 0;
                platforms = [];
                
                while (elements.platformsContainer.firstChild) { elements.platformsContainer.removeChild(elements.platformsContainer.firstChild); }
                while (elements.particlesContainer.firstChild) { elements.particlesContainer.removeChild(elements.particlesContainer.firstChild); }
                elements.heightScore.textContent = '0m';
                elements.heightFill.style.width = '0%';
                elements.player.classList.remove('jumping');
                
                // Reset background
                document.body.style.background = 'radial-gradient(ellipse at center, var(--bg-dark) 0%, var(--bg-darker) 100%)';
                
                return true;
            } catch (error) {
                throw new GameError('Game reset failed', { error });
            }
        }

        // Enhanced game start
        async function startGame() {
            try {
                gameState.currentState = 'playing';
                elements.menuScreen.classList.add('hidden');
                elements.gameOverScreen.classList.add('hidden');
                
                // Initialize audio on user interaction
                await soundEngine.resumeContext();
                
                resetGame();
                createPlayer();
                generateInitialPlatforms();
                
                Runner.run(runner, engine);
                gameState.isGameRunning = true;
                gameLoop();
            } catch (error) {
                console.error('Failed to start game:', error);
                showMenu();
            }
        }

        // Show menu
        function showMenu() {
            gameState.currentState = 'menu';
            gameState.isGameRunning = false;
            
            if (runner) Runner.stop(runner);
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            elements.menuScreen.classList.remove('hidden');
            elements.gameOverScreen.classList.add('hidden');
        }

        // Enhanced game loop with performance monitoring
        function gameLoop() {
            if (!gameState.isGameRunning) return;
            
            try {
                performanceMonitor.update();
                updateMovement();
                updateCamera();
                updateScore();
                
                gameLoopId = requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('Game loop error:', error);
                gameOver();
            }
        }

        // Enhanced event listeners
        function setupEventListeners() {
            // Keyboard events with better handling
            document.addEventListener('keydown', (e) => {
                if (gameState.keys[e.code]) return;
                gameState.keys[e.code] = true;
                
                if (gameState.currentState === 'playing') {
                    if (e.code === 'Space' || e.code === 'ArrowUp') {
                        e.preventDefault();
                        jump();
                    }
                }
                
                // Global shortcuts
                if (e.code === 'Escape') {
                    if (gameState.currentState === 'playing') {
                        showMenu();
                    }
                }
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.code] = false;
            });
            
            // Enhanced touch events
            document.addEventListener('touchstart', async (e) => {
                if (gameState.currentState === 'playing') {
                    e.preventDefault();
                    gameState.touchStartY = e.touches[0].clientY;
                    await soundEngine.resumeContext();
                    jump();
                } else if (gameState.currentState === 'menu') {
                    await soundEngine.init();
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (gameState.currentState === 'playing') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Button events
            elements.startButton.addEventListener('click', async () => {
                await soundEngine.init();
                startGame();
            });
            
            elements.restartButton.addEventListener('click', startGame);
            elements.menuButton.addEventListener('click', showMenu);
            
            // Visibility change handling
            document.addEventListener('visibilitychange', () => {
                if (document.hidden && gameState.isGameRunning) {
                    // Pause game when tab is hidden
                    gameState.isGameRunning = false;
                    if (runner) Runner.stop(runner);
                }
            });
            
            // Window resize handling
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    GAME_CONFIG.gameWidth = window.innerWidth;
                    GAME_CONFIG.gameHeight = window.innerHeight;
                    GAME_CONFIG.platformGap = Math.max(100, window.innerHeight * 0.15);
                }, 250);
            });
        }

        // Initialize particles with optimized settings
        function initParticles() {
            try {
                particlesJS('particles-js', {
                    particles: {
                        number: { value: window.innerWidth < 768 ? 40 : 60, density: { enable: true, value_area: 1000 } },
                        color: { value: ["#00d4ff", "#4ecdc4", "#ffffff"] },
                        shape: { type: "circle" },
                        opacity: { value: 0.3, random: true, anim: { enable: true, speed: 0.5 } },
                        size: { value: 2, random: true, anim: { enable: true, speed: 1 } },
                        line_linked: { 
                            enable: true, 
                            distance: 120, 
                            color: "#00d4ff", 
                            opacity: 0.2, 
                            width: 1 
                        },
                        move: { 
                            enable: true, 
                            speed: 0.8, 
                            direction: "none", 
                            random: true, 
                            straight: false, 
                            out_mode: "out" 
                        }
                    },
                    interactivity: {
                        detect_on: "window",
                        events: { 
                            onhover: { enable: true, mode: "repulse" }, 
                            onclick: { enable: false } 
                        },
                        modes: { 
                            repulse: { distance: 80, duration: 0.3 } 
                        }
                    },
                    retina_detect: true
                });
            } catch (error) {
                console.warn('Particles initialization failed:', error);
            }
        }

        // Initialize game
        async function init() {
            try {
                // Show loading screen
                elements.loading.classList.remove('hidden');
                
                // Initialize components
                await new Promise(resolve => setTimeout(resolve, 500)); // Simulate loading
                initPhysics();
                setupEventListeners();
                initParticles();
                
                // Update best score display
                elements.bestScore.textContent = 'Best: ' + gameState.score.best + 'm';
                
                // Hide loading and show menu
                elements.loading.classList.add('hidden');
                gameState.currentState = 'menu';
                showMenu();
                
            } catch (error) {
                console.error('Game initialization failed:', error);
                // 🛡️ SECURITY FIX: Create error message securely without innerHTML
                elements.loading.textContent = "";
                const errorDiv = document.createElement("div");
                errorDiv.style.cssText = "color: var(--danger-color); text-align: center;";
                const errorText = document.createElement("div");
                errorText.textContent = "Failed to load game.";
                const breakElement = document.createElement("br");
                const retryButton = document.createElement("button");
                retryButton.textContent = "Retry";
                retryButton.style.cssText = "margin-top: 1rem; padding: 0.5rem 1rem; background: var(--primary-color); border: none; border-radius: 4px; color: white; cursor: pointer;";
                retryButton.onclick = () => location.reload();
                errorDiv.appendChild(errorText);
                errorDiv.appendChild(breakElement);
                errorDiv.appendChild(retryButton);
                elements.loading.appendChild(errorDiv);            }
        }

        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Global error handler
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
        });
    </script>
</body>
</html>