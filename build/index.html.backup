<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>달빛 점프</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff6b6b;
            --accent-color: #4ecdc4;
            --bg-dark: #0a0a0f;
            --bg-darker: #060609;
            --text-light: #ffffff;
            --text-muted: #a0a0a0;
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --success-color: #00ff88;
            --warning-color: #ffaa00;
            --danger-color: #ff4757;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(ellipse at center, var(--bg-dark) 0%, var(--bg-darker) 100%);
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: var(--text-light);
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Performance optimized particles background */
        #particles-js {
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0.6;
            will-change: transform;
        }

        /* Main game container */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            z-index: 2;
        }

        /* Enhanced UI with glassmorphism */
        #ui {
            position: fixed;
            top: clamp(10px, 2vh, 20px);
            left: clamp(10px, 2vw, 20px);
            right: clamp(10px, 2vw, 20px);
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
            pointer-events: none;
        }

        .ui-element {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: clamp(8px, 1.5vh, 16px) clamp(12px, 3vw, 20px);
            font-weight: 600;
            font-size: clamp(0.9rem, 2.5vw, 1.2rem);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .ui-element:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        /* Enhanced height progress bar */
        #height-progress {
            position: fixed;
            left: 50%;
            top: clamp(10px, 2vh, 20px);
            transform: translateX(-50%);
            width: clamp(150px, 40vw, 250px);
            height: 8px;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            overflow: hidden;
            pointer-events: none;
        }

        #height-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            border-radius: 8px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.5);
            position: relative;
        }

        #height-fill::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 30px;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3));
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-30px); }
            100% { transform: translateX(100px); }
        }

        /* Screen transitions with improved UX */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(30px);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            opacity: 1;
            visibility: visible;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 2rem;
        }

        .screen.hidden {
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
        }

        .title {
            font-size: clamp(2.5rem, 8vw, 4rem);
            font-weight: 700;
            margin-bottom: clamp(1rem, 4vh, 2rem);
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 3s ease-in-out infinite alternate;
            letter-spacing: -0.02em;
        }

        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.3)); }
            to { filter: drop-shadow(0 0 40px rgba(0, 212, 255, 0.6)); }
        }

        .subtitle {
            font-size: clamp(0.9rem, 3vw, 1.1rem);
            color: var(--text-muted);
            margin-bottom: clamp(2rem, 6vh, 3rem);
            font-weight: 300;
            line-height: 1.6;
            max-width: 500px;
        }

        .instructions {
            margin-bottom: clamp(2rem, 6vh, 3rem);
            line-height: 1.8;
            font-size: clamp(0.95rem, 3vw, 1.1rem);
            color: var(--text-muted);
            max-width: 400px;
        }

        .instructions p {
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .key-hint {
            background: var(--glass-bg);
            padding: 0.3rem 0.8rem;
            border-radius: 6px;
            border: 1px solid var(--glass-border);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            font-weight: 500;
        }

        /* Enhanced buttons with better accessibility */
        .game-button {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            border: none;
            color: var(--text-light);
            font-size: clamp(1rem, 3.5vw, 1.2rem);
            font-weight: 600;
            padding: clamp(12px, 3vh, 18px) clamp(24px, 6vw, 36px);
            margin: 0.5rem;
            border-radius: 50px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 8px 32px rgba(0, 212, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            position: relative;
            overflow: hidden;
            min-width: 140px;
        }

        .game-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 48px rgba(0, 212, 255, 0.4);
            filter: brightness(1.1);
        }

        .game-button:hover::before {
            left: 100%;
        }

        .game-button:active {
            transform: translateY(0);
            transition: transform 0.1s;
        }

        .game-button:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.5);
        }

        /* Enhanced player with smooth animations */
        #player {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, var(--text-light), var(--primary-color));
            box-shadow: 
                0 0 20px rgba(0, 212, 255, 0.6),
                inset 2px 2px 4px rgba(255, 255, 255, 0.3);
            z-index: 999;
            will-change: transform;
            transition: filter 0.2s ease;
        }

        #player.jumping {
            animation: playerJump 0.3s ease-out;
        }

        @keyframes playerJump {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.3) drop-shadow(0 0 15px rgba(0, 212, 255, 0.8)); }
            100% { filter: brightness(1); }
        }

        /* Enhanced platforms with better visual hierarchy */
        .platform {
            position: absolute;
            font-family: 'JetBrains Mono', monospace;
            font-weight: 500;
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            color: var(--text-muted);
            z-index: 5;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            will-change: transform;
        }

        .platform.spring {
            color: var(--success-color);
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
            animation: springPulse 2s ease-in-out infinite;
        }

        @keyframes springPulse {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.2); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 136, 0.4); }
        }

        /* Particle effects with GPU acceleration */
        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 800;
            border-radius: 50%;
            will-change: transform, opacity;
        }

        .jump-particle {
            width: 3px;
            height: 3px;
            background: var(--primary-color);
            box-shadow: 0 0 6px var(--primary-color);
            animation: jumpParticleAnim 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes jumpParticleAnim {
            0% { 
                opacity: 1; 
                transform: scale(1) translateY(0); 
            }
            100% { 
                opacity: 0; 
                transform: scale(0.3) translateY(-60px); 
            }
        }

        .land-particle {
            width: 4px;
            height: 4px;
            background: var(--accent-color);
            box-shadow: 0 0 8px var(--accent-color);
            animation: landParticleAnim 0.4s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes landParticleAnim {
            0% { 
                opacity: 1; 
                transform: scale(1) translateX(0) translateY(0); 
            }
            100% { 
                opacity: 0; 
                transform: scale(0.2) translateX(var(--spread, 40px)) translateY(10px); 
            }
        }

        /* Loading screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--bg-darker);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(0, 212, 255, 0.1);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive design improvements */
        @media (max-width: 768px) {
            #ui {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
            
            .ui-element {
                font-size: clamp(0.8rem, 4vw, 1rem);
                padding: clamp(6px, 2vh, 12px) clamp(10px, 4vw, 16px);
            }

            #player {
                width: 20px;
                height: 20px;
            }
        }

        @media (max-height: 500px) {
            .title {
                font-size: clamp(2rem, 6vh, 3rem);
                margin-bottom: 1rem;
            }
            
            .instructions, .subtitle {
                margin-bottom: 1.5rem;
            }
        }

        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Focus indicators for keyboard navigation */
        .game-button:focus-visible,
        .ui-element:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }
        
        /* Danger warning effect */
        body.danger-warning {
            box-shadow: inset 0 0 50px rgba(255, 71, 87, 0.3);
            transition: box-shadow 0.3s ease;
        }
        
        /* Enhanced platform hover effects */
        .platform:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.2);
        }
        
        .platform.spring:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 4px 16px rgba(0, 255, 136, 0.3);
        }
    </style>
</head>
<body>
    <!-- Loading screen -->
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
    </div>

    <!-- Background particles -->
    <div id="particles-js"></div>
    
    <div id="game-container">
        <!-- Enhanced UI -->
        <div id="ui">
            <div class="ui-element" id="score">
                <span id="height">0m</span>
            </div>
            <div class="ui-element" id="best-score">
                최고: <span id="best">0m</span>
            </div>
        </div>

        <!-- Progress bar -->
        <div id="height-progress" title="높이 진행도 - 15000m 목표">
            <div id="height-fill"></div>
        </div>
        <div style="position: fixed; top: 35px; left: 50%; transform: translateX(-50%); font-size: 0.8rem; color: var(--text-muted); text-align: center; pointer-events: none;">높이 진행도</div>

        <!-- Game elements -->
        <div id="player"></div>
        <div id="platforms"></div>
        <div id="particles-container"></div>

        <!-- Menu Screen -->
        <div id="menu-screen" class="screen">
            <div class="title">MOONLIGHT JUMP</div>
            <div class="subtitle">중력을 거슬러 달까지 올라가세요</div>
            <div class="instructions">
                <p><span class="key-hint">스페이스</span> 점프</p>
                <p><span class="key-hint">A</span> <span class="key-hint">D</span> 이동</p>
                <p><span style="color: var(--text-muted);">모바일: 터치하여 점프</span></p>
            </div>
            <button id="start-button" class="game-button" role="button" aria-label="게임 시작">시작</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen hidden">
            <div class="title" style="background: linear-gradient(135deg, var(--danger-color), var(--warning-color)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">게임 오버</div>
            <div id="final-score" style="font-size: clamp(1.5rem, 5vw, 2rem); margin-bottom: clamp(1rem, 3vh, 1.5rem); font-weight: 600;">
                높이: <span>0m</span>
            </div>
            <div id="new-record" class="hidden" style="color: var(--success-color); font-size: clamp(1.2rem, 4vw, 1.5rem); margin-bottom: clamp(1rem, 3vh, 1.5rem); font-weight: 600;">
                🎉 신기록!
            </div>
            <div style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;">
                <button id="restart-button" class="game-button" role="button" aria-label="게임 재시작">다시하기</button>
                <button id="menu-button" class="game-button" role="button" aria-label="메뉴로 돌아가기">메뉴</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced error handling and performance monitoring
        class GameError extends Error {
            constructor(message, context = {}) {
                super(message);
                this.context = context;
                this.name = 'GameError';
            }
        }

        // Performance monitor
        class PerformanceMonitor {
            constructor() {
                this.fps = 60;
                this.frameTime = 0;
                this.lastFrameTime = performance.now();
            }

            update() {
                const currentTime = performance.now();
                this.frameTime = currentTime - this.lastFrameTime;
                this.fps = Math.round(1000 / this.frameTime);
                this.lastFrameTime = currentTime;
                
                // Auto-adjust quality based on performance
                if (this.fps < 30) {
                    this.optimizePerformance();
                }
            }

            optimizePerformance() {
                // Reduce particle count on low performance
                const particlesContainer = document.getElementById('particles-container');
                if (particlesContainer && particlesContainer.children.length > 20) {
                    Array.from(particlesContainer.children).slice(0, 10).forEach(child => child.remove());
                }
            }
        }

        const performanceMonitor = new PerformanceMonitor();

        // Enhanced game configuration with responsive values
        const GAME_CONFIG = {
            jumpPower: 16.5,
            horizontalSpeed: 3.2,
            platformGap: Math.max(80, window.innerHeight * 0.12),
            gameWidth: window.innerWidth,
            gameHeight: window.innerHeight,
            maxHeight: 15000,
            particleLimit: 25,
            // Enhanced platform generation - tighter spacing for infinite feel
            chunkSize: 25, // platforms per chunk
            chunkHeight: 1500, // height per chunk in pixels
            generationAhead: 5, // chunks to generate ahead
            cleanupBehind: 2000, // pixels behind player to cleanup
            minPlatformWidth: 60, // minimum platform width
            maxPlatformWidth: 140, // maximum platform width
            platformHeightRange: 60, // vertical spacing range
            // Camera settings - smoother and more responsive
            cameraDeadzone: 30,
            cameraLookAhead: 60,
            cameraSmoothness: 0.08,
            maxCameraShake: 4,
            // Physics settings - more forgiving
            coyoteTime: 180, // ms grace period for jumping
            jumpBufferTime: 120, // ms to buffer jump input
            variableJumpFactor: 0.7,
            maxHorizontalVelocity: 3.5,
            airControl: 0.85 // how much control player has in air
        };

        // Matter.js modules
        const { Engine, World, Bodies, Body, Events, Runner } = Matter;

        // Physics engine
        let engine, world, runner;
        let playerBody;
        let platforms = [];
        let gameLoopId = null;

        // Enhanced game state with better state management
        let gameState = {
            currentState: 'loading',
            camera: { 
                y: 0, 
                targetY: 0,
                offsetX: 0,
                velocity: { x: 0, y: 0 }
            },
            score: { height: 0, best: parseInt(localStorage.getItem('quantum-jump-best') || '0') },
            keys: {},
            canJump: false,
            isGameRunning: false,
            touchStartY: 0,
            lastJumpTime: 0,
            particleCount: 0,
            // Enhanced physics state
            lastGroundedTime: 0,
            jumpBufferTime: 0,
            isJumping: false,
            jumpHoldTime: 0,
            // Chunk management
            currentChunk: 0,
            loadedChunks: new Set(),
            platformChunks: new Map()
        };

        // DOM elements with null checks
        const elements = {
            loading: document.getElementById('loading'),
            player: document.getElementById('player'),
            platformsContainer: document.getElementById('platforms'),
            particlesContainer: document.getElementById('particles-container'),
            heightScore: document.getElementById('height'),
            bestScore: document.getElementById('best'),
            heightFill: document.getElementById('height-fill'),
            menuScreen: document.getElementById('menu-screen'),
            gameOverScreen: document.getElementById('game-over-screen'),
            finalScore: document.querySelector('#final-score span'),
            newRecord: document.getElementById('new-record'),
            startButton: document.getElementById('start-button'),
            restartButton: document.getElementById('restart-button'),
            menuButton: document.getElementById('menu-button')
        };

        // Enhanced Sound System with user interaction handling
        class SoundEngine {
            constructor() {
                this.audioContext = null;
                this.masterGain = null;
                this.isInitialized = false;
                this.soundQueue = [];
            }

            async init() {
                if (this.isInitialized) return;
                
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.audioContext.createGain();
                    this.masterGain.connect(this.audioContext.destination);
                    this.masterGain.gain.value = 0.2;
                    this.isInitialized = true;
                    
                    // Process queued sounds
                    this.soundQueue.forEach(sound => sound());
                    this.soundQueue = [];
                } catch (e) {
                    console.warn('Audio initialization failed:', e);
                }
            }

            async resumeContext() {
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
            }

            playTone(frequency, duration, type = 'sine', envelope = null) {
                if (!this.isInitialized) {
                    this.soundQueue.push(() => this.playTone(frequency, duration, type, envelope));
                    return;
                }

                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.masterGain);

                    oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                    oscillator.type = type;

                    if (envelope) {
                        gainNode.gain.setValueAtTime(envelope.attack, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(envelope.decay, this.audioContext.currentTime + duration * 0.3);
                        gainNode.gain.exponentialRampToValueAtTime(envelope.sustain, this.audioContext.currentTime + duration * 0.7);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    } else {
                        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    }

                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration);
                } catch (e) {
                    console.warn('Sound playback failed:', e);
                }
            }

            jump() {
                this.playTone(440, 0.15, 'square', { attack: 0.3, decay: 0.2, sustain: 0.1 });
                setTimeout(() => this.playTone(660, 0.08, 'sine'), 30);
            }

            land() {
                this.playTone(220, 0.12, 'triangle', { attack: 0.4, decay: 0.2, sustain: 0.1 });
            }

            spring() {
                this.playTone(880, 0.25, 'sawtooth', { attack: 0.6, decay: 0.3, sustain: 0.2 });
            }

            gameOver() {
                this.playTone(200, 0.4, 'triangle');
                setTimeout(() => this.playTone(150, 0.4, 'triangle'), 150);
                setTimeout(() => this.playTone(100, 0.8, 'triangle'), 300);
            }

            achievement() {
                [523, 659, 784, 1047].forEach((freq, i) => {
                    setTimeout(() => this.playTone(freq, 0.2, 'sine'), i * 100);
                });
            }
        }

        const soundEngine = new SoundEngine();

        // Enhanced Particle System with memory management
        class ParticleSystem {
            static createJumpParticles(x, y) {
                if (gameState.particleCount > GAME_CONFIG.particleLimit) return;
                
                const particleCount = Math.min(6, GAME_CONFIG.particleLimit - gameState.particleCount);
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle jump-particle';
                    particle.style.left = (x + Math.random() * 16 - 8) + 'px';
                    particle.style.top = (y + Math.random() * 8 - 4) + 'px';
                    elements.particlesContainer.appendChild(particle);
                    gameState.particleCount++;
                    
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                            gameState.particleCount--;
                        }
                    }, 600);
                }
            }

            static createLandParticles(x, y) {
                if (gameState.particleCount > GAME_CONFIG.particleLimit) return;
                
                const particleCount = Math.min(8, GAME_CONFIG.particleLimit - gameState.particleCount);
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle land-particle';
                    const spread = (Math.random() - 0.5) * 50;
                    particle.style.setProperty('--spread', spread + 'px');
                    particle.style.left = (x + Math.random() * 16 - 8) + 'px';
                    particle.style.top = (y + 10) + 'px';
                    elements.particlesContainer.appendChild(particle);
                    gameState.particleCount++;
                    
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                            gameState.particleCount--;
                        }
                    }, 400);
                }
            }

            static createSpringParticles(x, y) {
                if (gameState.particleCount > GAME_CONFIG.particleLimit) return;
                
                const particleCount = Math.min(10, GAME_CONFIG.particleLimit - gameState.particleCount);
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.width = '2px';
                    particle.style.height = '2px';
                    particle.style.background = 'var(--success-color)';
                    particle.style.borderRadius = '50%';
                    particle.style.left = (x + Math.random() * 30 - 15) + 'px';
                    particle.style.top = (y + Math.random() * 8 - 4) + 'px';
                    particle.style.boxShadow = '0 0 8px var(--success-color)';
                    particle.style.animation = 'jumpParticleAnim 0.7s ease-out forwards';
                    elements.particlesContainer.appendChild(particle);
                    gameState.particleCount++;
                    
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                            gameState.particleCount--;
                        }
                    }, 700);
                }
            }
        }

        // Initialize physics engine with error handling
        function initPhysics() {
            try {
                engine = Engine.create();
                world = engine.world;
                runner = Runner.create();
                
                engine.world.gravity.y = 1;
                engine.world.gravity.x = 0;
                
                // Enhanced collision detection with better physics
                Events.on(engine, 'collisionStart', function(event) {
                    event.pairs.forEach(pair => {
                        const { bodyA, bodyB } = pair;
                        
                        // Ground detection with improved precision
                        if ((bodyA.label === 'player' && bodyB.label === 'ground-sensor') ||
                            (bodyB.label === 'player' && bodyA.label === 'ground-sensor')) {
                            
                            // Only register landing if player is moving downward or stationary
                            if (playerBody && playerBody.velocity.y > -3) {
                                gameState.canJump = true;
                                gameState.lastGroundedTime = Date.now();
                                
                                // Landing effects only if we were actually falling
                                if (playerBody.velocity.y > 2) {
                                    soundEngine.land();
                                    ParticleSystem.createLandParticles(playerBody.position.x, playerBody.position.y);
                                    
                                    // Reduced camera shake for smoother experience
                                    const shakeIntensity = Math.min(playerBody.velocity.y * 0.3, 3);
                                    cameraSystem.addShake(shakeIntensity, 100);
                                }
                            }
                        }
                        
                        // Enhanced spring platform mechanics
                        if ((bodyA.label === 'player' && bodyB.label === 'spring') ||
                            (bodyB.label === 'player' && bodyA.label === 'spring')) {
                            
                            // Only trigger spring if player is falling and close to platform
                            if (playerBody && playerBody.velocity.y > 0.5) {
                                const springBody = bodyA.label === 'spring' ? bodyA : bodyB;
                                const playerPos = playerBody.position;
                                const springPos = springBody.position;
                                
                                // More generous spring trigger area
                                if (Math.abs(playerPos.x - springPos.x) < 60 && 
                                    playerPos.y < springPos.y + 25) {
                                    
                                    setTimeout(() => {
                                        if (playerBody) {
                                            // Super jump with enhanced power - preserve horizontal momentum
                                            const horizontalBoost = Math.sign(playerBody.velocity.x) * Math.min(Math.abs(playerBody.velocity.x) * 1.2, 4);
                                            Body.setVelocity(playerBody, { 
                                                x: playerBody.velocity.x + horizontalBoost, 
                                                y: -24 
                                            });
                                            
                                            // Reset jump state to allow immediate control
                                            gameState.canJump = false;
                                            platformerPhysics.jumpCount = 0;
                                            platformerPhysics.isJumping = true;
                                            platformerPhysics.jumpStartTime = Date.now();
                                            
                                            soundEngine.spring();
                                            ParticleSystem.createSpringParticles(playerBody.position.x, playerBody.position.y);
                                            cameraSystem.addShake(2, 150);
                                            
                                            // Enhanced visual spring effect
                                            const springPlatform = platforms.find(p => p.body === springBody);
                                            if (springPlatform && springPlatform.element) {
                                                springPlatform.element.style.transform = 'scaleY(0.6) translateY(5px)';
                                                springPlatform.element.style.transition = 'transform 0.1s ease-out';
                                                setTimeout(() => {
                                                    springPlatform.element.style.transform = 'scaleY(1.1)';
                                                    setTimeout(() => {
                                                        springPlatform.element.style.transform = '';
                                                        springPlatform.element.style.transition = '';
                                                    }, 150);
                                                }, 100);
                                            }
                                        }
                                    }, 20);
                                }
                            }
                        }
                    });
                });
                
                Events.on(engine, 'collisionEnd', function(event) {
                    event.pairs.forEach(pair => {
                        const { bodyA, bodyB } = pair;
                        
                        // Ground detection end with improved stability
                        if ((bodyA.label === 'player' && bodyB.label === 'ground-sensor') ||
                            (bodyB.label === 'player' && bodyA.label === 'ground-sensor')) {
                            
                            // Immediate check if still touching any other ground sensors
                            setTimeout(() => { 
                                let stillGrounded = false;
                                if (playerBody && platforms.length > 0) {
                                    // Check collision with all existing ground sensors
                                    const activeSensors = platforms.filter(p => p.sensor).map(p => p.sensor);
                                    const collisions = Matter.Query.collides(playerBody, activeSensors);
                                    stillGrounded = collisions.length > 0;
                                }
                                
                                if (!stillGrounded && platformerPhysics.groundCheckDelay === 0) {
                                    gameState.canJump = false;
                                }
                            }, 30);
                        }
                    });
                });

                return true;
            } catch (error) {
                throw new GameError('Physics initialization failed', { error });
            }
        }

        // Create player with enhanced properties
        function createPlayer() {
            try {
                const startX = GAME_CONFIG.gameWidth / 2;
                const startY = GAME_CONFIG.gameHeight - 150;
                
                playerBody = Bodies.circle(startX, startY, 12, {
                    restitution: 0,
                    friction: 0.6,
                    frictionAir: 0.015,
                    frictionStatic: 0.8,
                    density: 0.001,
                    label: 'player'
                });
                
                World.add(world, playerBody);
                return true;
            } catch (error) {
                throw new GameError('Player creation failed', { error });
            }
        }

        // Enhanced platform creation with better distribution
        function createPlatform(x, y, type, width, id = null) {
            try {
                const platformWidth = Math.max(GAME_CONFIG.minPlatformWidth, width * 18);
                const platformHeight = 16;
                
                // Physics body with proper collision properties
                const platformBody = Bodies.rectangle(x + platformWidth/2, y + platformHeight/2, platformWidth, platformHeight, {
                    isStatic: true,
                    friction: 0.8,
                    restitution: 0,
                    label: type === 'spring' ? 'spring' : 'platform'
                });
                
                // Enhanced ground sensor for more precise detection
                const sensorBody = Bodies.rectangle(x + platformWidth/2, y - 1, platformWidth + 4, 6, {
                    isStatic: true,
                    isSensor: true,
                    label: 'ground-sensor'
                });
                
                World.add(world, [platformBody, sensorBody]);
                
                // Visual element with better styling
                const element = document.createElement('div');
                element.className = `platform ${type}`;
                element.textContent = (type === 'spring' ? '↑' : '═').repeat(Math.max(3, Math.floor(width)));
                element.style.left = x + 'px';
                element.style.top = y + 'px';
                element.style.width = platformWidth + 'px';
                element.style.height = platformHeight + 'px';
                
                elements.platformsContainer.appendChild(element);
                platforms.push({ element, body: platformBody, sensor: sensorBody, x, y, type, id, width: platformWidth });
                
                return true;
            } catch (error) {
                console.warn('Platform creation failed:', error);
                return false;
            }
        }

        // Enhanced chunk-based platform generation system
        class ChunkManager {
            constructor() {
                this.chunks = new Map();
                this.loadedChunks = new Set();
                this.platformCount = 0;
            }
            
            getChunkId(height) {
                return Math.floor(height / GAME_CONFIG.chunkHeight);
            }
            
            generateChunk(chunkId) {
                if (this.chunks.has(chunkId)) return this.chunks.get(chunkId);
                
                const platforms = [];
                const baseY = GAME_CONFIG.gameHeight - 80 - (chunkId * GAME_CONFIG.chunkHeight);
                const chunkHeight = GAME_CONFIG.chunkHeight;
                const platformSpacing = chunkHeight / GAME_CONFIG.chunkSize;
                
                for (let i = 0; i < GAME_CONFIG.chunkSize; i++) {
                    const platformIndex = chunkId * GAME_CONFIG.chunkSize + i;
                    
                    // Better platform positioning with guaranteed reachability
                    const y = baseY - (i * platformSpacing) - (Math.random() * 20 - 10);
                    const x = this.generateReachablePlatformX(platforms, i);
                    
                    let type = 'normal';
                    if (platformIndex % 15 === 0 && platformIndex > 0) type = 'spring';
                    else if (platformIndex > 20 && Math.random() < 0.12) type = 'spring';
                    
                    const width = this.generatePlatformWidth(platformIndex);
                    platforms.push({ x, y, type, width, id: platformIndex });
                }
                
                this.chunks.set(chunkId, platforms);
                return platforms;
            }
            
            generateReachablePlatformX(existingPlatforms, currentIndex) {
                const gameWidth = GAME_CONFIG.gameWidth;
                const maxJumpDistance = 180; // Maximum horizontal jump distance
                
                if (currentIndex === 0 || existingPlatforms.length === 0) {
                    // First platform in chunk - place randomly but not too close to edges
                    return Math.random() * (gameWidth - 200) + 100;
                }
                
                // Get previous platform position
                const prevPlatform = existingPlatforms[existingPlatforms.length - 1];
                const prevX = prevPlatform.x + (prevPlatform.width * 18) / 2; // Center of previous platform
                
                // Generate position within jump range but with some randomness
                const minX = Math.max(50, prevX - maxJumpDistance * 0.8);
                const maxX = Math.min(gameWidth - 100, prevX + maxJumpDistance * 0.8);
                
                return minX + Math.random() * (maxX - minX);
            }
            
            generatePlatformWidth(index) {
                // More generous platform sizes with gradual difficulty
                const difficultyFactor = Math.min(index / 200, 0.4);
                const baseSize = 6; // Larger base size
                
                if (index < 10) return 8; // Tutorial platforms are larger
                if (Math.random() < 0.7 - difficultyFactor) return baseSize;
                if (Math.random() < 0.8) return baseSize - 1;
                return Math.max(4, baseSize - 2);
            }
            
            loadChunk(chunkId) {
                if (this.loadedChunks.has(chunkId)) return;
                
                const platforms = this.generateChunk(chunkId);
                platforms.forEach(platformData => {
                    createPlatform(platformData.x, platformData.y, platformData.type, platformData.width, platformData.id);
                });
                
                this.loadedChunks.add(chunkId);
            }
            
            unloadChunk(chunkId) {
                if (!this.loadedChunks.has(chunkId)) return;
                
                const platforms = this.chunks.get(chunkId);
                if (platforms) {
                    platforms.forEach(platformData => {
                        this.removePlatformById(platformData.id);
                    });
                }
                
                this.loadedChunks.delete(chunkId);
            }
            
            removePlatformById(id) {
                platforms = platforms.filter(platform => {
                    if (platform.id === id) {
                        World.remove(world, [platform.body, platform.sensor]);
                        if (platform.element && platform.element.parentNode) {
                            platform.element.parentNode.removeChild(platform.element);
                        }
                        return false;
                    }
                    return true;
                });
            }
            
            updateChunks(playerHeight) {
                const currentChunk = this.getChunkId(playerHeight);
                
                // Load chunks ahead
                for (let i = currentChunk; i <= currentChunk + GAME_CONFIG.generationAhead; i++) {
                    this.loadChunk(i);
                }
                
                // Unload chunks behind
                const chunksToUnload = [];
                this.loadedChunks.forEach(chunkId => {
                    if (chunkId < currentChunk - 1) {
                        chunksToUnload.push(chunkId);
                    }
                });
                
                chunksToUnload.forEach(chunkId => this.unloadChunk(chunkId));
            }
        }
        
        const chunkManager = new ChunkManager();
        
        // Enhanced platform generation with better spacing
        function generateInitialPlatforms() {
            try {
                // Starting platform
                createPlatform(GAME_CONFIG.gameWidth / 2 - 80, GAME_CONFIG.gameHeight - 80, 'normal', 8, 0);
                
                // Load initial chunks
                for (let i = 0; i <= GAME_CONFIG.generationAhead; i++) {
                    chunkManager.loadChunk(i);
                }
                
                return true;
            } catch (error) {
                throw new GameError('Platform generation failed', { error });
            }
        }

        // Professional platformer physics system
        class PlatformerPhysics {
            constructor() {
                this.coyoteTimer = 0;
                this.jumpBufferTimer = 0;
                this.isJumping = false;
                this.jumpStartTime = 0;
                this.wasGrounded = false;
                this.jumpCount = 0;
                this.groundCheckDelay = 0;
            }
            
            update(deltaTime = 16.67) {
                const currentTime = Date.now();
                
                // Update timers
                this.coyoteTimer = Math.max(0, this.coyoteTimer - deltaTime);
                this.jumpBufferTimer = Math.max(0, this.jumpBufferTimer - deltaTime);
                this.groundCheckDelay = Math.max(0, this.groundCheckDelay - deltaTime);
                
                // Check if we just left the ground (start coyote time)
                if (this.wasGrounded && !gameState.canJump && this.groundCheckDelay === 0) {
                    this.coyoteTimer = GAME_CONFIG.coyoteTime;
                }
                this.wasGrounded = gameState.canJump;
                
                // Reset jump count when grounded
                if (gameState.canJump) {
                    this.jumpCount = 0;
                }
                
                // Enhanced variable jump height
                if (this.isJumping && playerBody) {
                    const jumpDuration = currentTime - this.jumpStartTime;
                    const maxJumpTime = 350; // Longer hold time for better control
                    
                    // More responsive jump control
                    const isJumpHeld = gameState.keys['Space'] || gameState.keys['ArrowUp'];
                    
                    if (!isJumpHeld || jumpDuration > maxJumpTime) {
                        if (playerBody.velocity.y < -2) { // Only cut if moving up significantly
                            Body.setVelocity(playerBody, {
                                x: playerBody.velocity.x,
                                y: playerBody.velocity.y * GAME_CONFIG.variableJumpFactor
                            });
                        }
                        this.isJumping = false;
                    }
                }
                
                // Process buffered jump if we land or in coyote time
                if (this.jumpBufferTimer > 0 && (gameState.canJump || this.coyoteTimer > 0)) {
                    this.executeJump();
                    this.jumpBufferTimer = 0;
                }
            }
            
            requestJump() {
                const currentTime = Date.now();
                
                // Immediate jump if grounded or in coyote time
                if ((gameState.canJump || this.coyoteTimer > 0) && 
                    currentTime - gameState.lastJumpTime > 80 && this.jumpCount === 0) {
                    this.executeJump();
                } else {
                    // Buffer the jump input for more responsive feel
                    this.jumpBufferTimer = GAME_CONFIG.jumpBufferTime;
                }
            }
            
            executeJump() {
                if (!playerBody) return;
                
                const currentTime = Date.now();
                
                // More lenient jump velocity check
                if (playerBody.velocity.y >= -3 && this.jumpCount === 0) {
                    Body.setVelocity(playerBody, { 
                        x: playerBody.velocity.x, 
                        y: -GAME_CONFIG.jumpPower 
                    });
                    
                    gameState.canJump = false;
                    gameState.lastJumpTime = currentTime;
                    this.coyoteTimer = 0;
                    this.isJumping = true;
                    this.jumpStartTime = currentTime;
                    this.jumpCount = 1;
                    this.groundCheckDelay = 100; // Prevent immediate ground detection after jump
                    
                    soundEngine.jump();
                    ParticleSystem.createJumpParticles(playerBody.position.x, playerBody.position.y);
                    cameraSystem.addShake(2, 150); // Reduced shake for smoother experience
                    
                    // Visual feedback
                    elements.player.classList.add('jumping');
                    setTimeout(() => elements.player.classList.remove('jumping'), 300);
                }
            }
            
            reset() {
                this.coyoteTimer = 0;
                this.jumpBufferTimer = 0;
                this.isJumping = false;
                this.jumpStartTime = 0;
                this.wasGrounded = false;
                this.jumpCount = 0;
                this.groundCheckDelay = 0;
            }
        }
        
        const platformerPhysics = new PlatformerPhysics();
        
        // Enhanced jump function with professional platformer mechanics
        function jump() {
            platformerPhysics.requestJump();
        }

        // Enhanced movement with better physics
        function updateMovement() {
            if (!playerBody) return;
            
            let inputForce = 0;
            if (gameState.keys['ArrowLeft'] || gameState.keys['KeyA']) inputForce = -1;
            if (gameState.keys['ArrowRight'] || gameState.keys['KeyD']) inputForce = 1;
            
            if (inputForce !== 0) {
                // Different force based on whether player is grounded or in air
                const baseForce = gameState.canJump ? 0.004 : 0.004 * GAME_CONFIG.airControl;
                const forceX = inputForce * baseForce;
                
                // Apply acceleration curve - faster initial acceleration, then tapering
                const currentSpeed = Math.abs(playerBody.velocity.x);
                const speedRatio = currentSpeed / GAME_CONFIG.maxHorizontalVelocity;
                const accelerationMultiplier = Math.max(0.3, 1 - speedRatio * 0.7);
                
                Body.applyForce(playerBody, playerBody.position, { 
                    x: forceX * accelerationMultiplier, 
                    y: 0 
                });
            } else if (gameState.canJump) {
                // Ground friction when no input
                const friction = 0.85;
                Body.setVelocity(playerBody, { 
                    x: playerBody.velocity.x * friction, 
                    y: playerBody.velocity.y 
                });
            }
            
            // Enhanced velocity limits
            const maxVelocity = GAME_CONFIG.maxHorizontalVelocity;
            if (Math.abs(playerBody.velocity.x) > maxVelocity) {
                Body.setVelocity(playerBody, { 
                    x: Math.sign(playerBody.velocity.x) * maxVelocity, 
                    y: playerBody.velocity.y 
                });
            }
            
            // Smooth screen wrapping instead of hard bounds
            const padding = 20;
            if (playerBody.position.x < -padding) {
                Body.setPosition(playerBody, { x: GAME_CONFIG.gameWidth + padding, y: playerBody.position.y });
            } else if (playerBody.position.x > GAME_CONFIG.gameWidth + padding) {
                Body.setPosition(playerBody, { x: -padding, y: playerBody.position.y });
            }
        }

        // Professional camera system with deadzone, look-ahead, and smooth movement
        class CameraSystem {
            constructor() {
                this.position = { x: 0, y: 0 };
                this.target = { x: 0, y: 0 };
                this.velocity = { x: 0, y: 0 };
                this.shake = { x: 0, y: 0, intensity: 0, duration: 0 };
                this.previousPlayerPos = { x: 0, y: 0 };
            }
            
            update(player, deltaTime = 16.67) {
                if (!player) return { x: this.position.x, y: this.position.y };
                
                const playerPos = player.position;
                const playerVel = player.velocity;
                
                // Smooth look-ahead based on actual movement, not just velocity
                const actualVelX = (playerPos.x - this.previousPlayerPos.x) * (1000 / deltaTime);
                const actualVelY = (playerPos.y - this.previousPlayerPos.y) * (1000 / deltaTime);
                this.previousPlayerPos = { x: playerPos.x, y: playerPos.y };
                
                // Calculate target position with smarter look-ahead
                const lookAheadX = Math.sign(actualVelX) * Math.min(Math.abs(actualVelX) * 8, GAME_CONFIG.cameraLookAhead);
                const lookAheadY = playerVel.y < 0 ? Math.min(Math.abs(playerVel.y) * 3, GAME_CONFIG.cameraLookAhead * 0.3) : 0;
                
                // Target calculation - keep player slightly below center for better upward view
                this.target.x = GAME_CONFIG.gameWidth / 2 - playerPos.x - lookAheadX;
                this.target.y = Math.min(0, GAME_CONFIG.gameHeight * 0.6 - playerPos.y - lookAheadY);
                
                // Enhanced deadzone with hysteresis to prevent jitter
                const deadzoneX = GAME_CONFIG.cameraDeadzone;
                const currentPlayerScreenX = playerPos.x + this.position.x;
                const screenCenterX = GAME_CONFIG.gameWidth / 2;
                const offsetFromCenter = currentPlayerScreenX - screenCenterX;
                
                // Only update X target if player is outside deadzone or moving away from center
                if (Math.abs(offsetFromCenter) < deadzoneX && Math.abs(actualVelX) < 1) {
                    this.target.x = this.position.x;
                }
                
                // Adaptive smoothing - faster when far from target, slower when close
                const distanceX = Math.abs(this.target.x - this.position.x);
                const distanceY = Math.abs(this.target.y - this.position.y);
                
                const smoothnessX = Math.min(GAME_CONFIG.cameraSmoothness * (1 + distanceX / 300), 0.25);
                const smoothnessY = Math.min(GAME_CONFIG.cameraSmoothness * (1 + distanceY / 200), 0.2);
                
                // Update camera velocity with different smoothing for X and Y
                this.velocity.x = (this.target.x - this.position.x) * smoothnessX;
                this.velocity.y = (this.target.y - this.position.y) * smoothnessY;
                
                // Apply velocity with frame-rate independent movement
                const frameMultiplier = Math.min(deltaTime / 16.67, 2); // Cap multiplier to prevent jumps
                this.position.x += this.velocity.x * frameMultiplier;
                this.position.y += this.velocity.y * frameMultiplier;
                
                // Update camera shake with reduced intensity
                this.updateShake(deltaTime);
                
                // Apply final position with shake
                const finalX = this.position.x + this.shake.x;
                const finalY = this.position.y + this.shake.y;
                
                return { x: finalX, y: finalY };
            }
            
            updateShake(deltaTime) {
                if (this.shake.duration <= 0) {
                    this.shake.x = 0;
                    this.shake.y = 0;
                    return;
                }
                
                this.shake.duration -= deltaTime;
                const intensity = Math.min(this.shake.intensity * (this.shake.duration / 1000), GAME_CONFIG.maxCameraShake);
                
                this.shake.x = (Math.random() - 0.5) * intensity;
                this.shake.y = (Math.random() - 0.5) * intensity;
            }
            
            addShake(intensity, duration) {
                // Limit shake intensity to prevent disorienting camera movement
                const limitedIntensity = Math.min(intensity, GAME_CONFIG.maxCameraShake);
                this.shake.intensity = Math.max(this.shake.intensity, limitedIntensity);
                this.shake.duration = Math.max(this.shake.duration, duration);
            }
            
            reset() {
                this.position = { x: 0, y: 0 };
                this.target = { x: 0, y: 0 };
                this.velocity = { x: 0, y: 0 };
                this.shake = { x: 0, y: 0, intensity: 0, duration: 0 };
                this.previousPlayerPos = { x: 0, y: 0 };
            }
        }
        
        const cameraSystem = new CameraSystem();
        
        // Enhanced camera with smoother movement
        function updateCamera() {
            if (!playerBody) return;
            
            const cameraPos = cameraSystem.update(playerBody);
            
            // Update player visual position
            elements.player.style.left = (playerBody.position.x - 12) + 'px';
            elements.player.style.top = (playerBody.position.y - 12 + cameraPos.y) + 'px';
            
            // Update platforms position
            platforms.forEach(platform => {
                platform.element.style.transform = `translateY(${cameraPos.y}px)`;
            });
            
            // Update particles container
            elements.particlesContainer.style.transform = `translateY(${cameraPos.y}px)`;
            
            // Store camera position for other systems
            gameState.camera.y = cameraPos.y;
        }

        // Enhanced score system with achievements
        function updateScore() {
            if (!playerBody) return;
            
            const height = Math.max(0, Math.floor((GAME_CONFIG.gameHeight - playerBody.position.y) / 8));
            if (height > gameState.score.height) {
                const previousHeight = gameState.score.height;
                gameState.score.height = height;
                elements.heightScore.textContent = height + 'm';
                
                // Update progress bar (cycles every 1000m for infinite feel)
                const cycleHeight = height % 1000;
                const progress = (cycleHeight / 1000) * 100;
                elements.heightFill.style.width = progress + '%';
                
                // Update chunk-based platform generation
                chunkManager.updateChunks(height * 8);
                
                // Achievement milestones
                const milestones = [500, 1000, 2000, 5000, 10000];
                const reachedMilestone = milestones.find(milestone => 
                    previousHeight < milestone && height >= milestone
                );
                
                if (reachedMilestone) {
                    soundEngine.achievement();
                }
                
                // Dynamic background based on height with smoother transitions
                const hue = Math.min(300, 240 - height / 80);
                const saturation = Math.min(80, 60 + height / 500);
                const lightness = Math.max(2, 8 - height / 1500);
                document.body.style.background = `radial-gradient(ellipse at center, 
                    hsl(${hue}, ${saturation}%, ${lightness}%) 0%, 
                    hsl(${hue - 15}, ${saturation + 10}%, ${lightness - 1}%) 100%)`;
                    
                // Subtle atmosphere effects at different heights
                if (height % 1000 === 0 && height > 0) {
                    // Milestone celebration effect
                    document.body.style.filter = 'brightness(1.2) saturate(1.3)';
                    setTimeout(() => {
                        document.body.style.filter = '';
                    }, 1000);
                }
            }
            
            // Enhanced game over detection with grace period
            if (playerBody.position.y > GAME_CONFIG.gameHeight + 300) {
                gameOver();
            }
            
            // Warning effects when player is falling too far
            if (playerBody.position.y > GAME_CONFIG.gameHeight + 100 && playerBody.velocity.y > 5) {
                // Red screen edge effect
                if (!document.body.classList.contains('danger-warning')) {
                    document.body.classList.add('danger-warning');
                    setTimeout(() => document.body.classList.remove('danger-warning'), 2000);
                }
            }
        }
        
        // Legacy platform generation functions removed - now using ChunkManager

        // Enhanced game over with better UX
        function gameOver() {
            gameState.isGameRunning = false;
            gameState.currentState = 'gameOver';
            
            if (runner) Runner.stop(runner);
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            soundEngine.gameOver();
            
            elements.finalScore.textContent = gameState.score.height + 'm';
            
            if (gameState.score.height > gameState.score.best) {
                gameState.score.best = gameState.score.height;
                localStorage.setItem('quantum-jump-best', gameState.score.best);
                elements.newRecord.classList.remove('hidden');
                elements.bestScore.textContent = 'Best: ' + gameState.score.best + 'm';
            } else {
                elements.newRecord.classList.add('hidden');
            }
            
            setTimeout(() => {
                elements.gameOverScreen.classList.remove('hidden');
            }, 500);
        }

        // Enhanced game reset with system cleanup
        function resetGame() {
            try {
                if (world) {
                    World.clear(world);
                    Engine.clear(engine);
                }
                
                // Reset all game systems
                gameState.camera.y = 0;
                gameState.score.height = 0;
                gameState.canJump = false;
                gameState.lastJumpTime = 0;
                gameState.particleCount = 0;
                gameState.lastGroundedTime = 0;
                gameState.jumpBufferTime = 0;
                gameState.isJumping = false;
                gameState.jumpHoldTime = 0;
                gameState.currentChunk = 0;
                gameState.loadedChunks.clear();
                gameState.platformChunks.clear();
                
                platforms = [];
                lastGeneratedHeight = 0;
                lastFrameTime = performance.now();
                
                // Reset subsystems
                cameraSystem.reset();
                platformerPhysics.reset();
                chunkManager.chunks.clear();
                chunkManager.loadedChunks.clear();
                
                elements.platformsContainer.innerHTML = '';
                elements.particlesContainer.innerHTML = '';
                elements.heightScore.textContent = '0m';
                elements.heightFill.style.width = '0%';
                elements.player.classList.remove('jumping');
                
                // Reset background
                document.body.style.background = 'radial-gradient(ellipse at center, var(--bg-dark) 0%, var(--bg-darker) 100%)';
                
                return true;
            } catch (error) {
                throw new GameError('Game reset failed', { error });
            }
        }

        // Enhanced game start
        async function startGame() {
            try {
                gameState.currentState = 'playing';
                elements.menuScreen.classList.add('hidden');
                elements.gameOverScreen.classList.add('hidden');
                
                // Initialize audio on user interaction
                await soundEngine.resumeContext();
                
                resetGame();
                createPlayer();
                generateInitialPlatforms();
                
                Runner.run(runner, engine);
                gameState.isGameRunning = true;
                
                // Smooth game start transition
                elements.player.style.opacity = '0';
                elements.player.style.transform = 'scale(0.5)';
                setTimeout(() => {
                    elements.player.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
                    elements.player.style.opacity = '1';
                    elements.player.style.transform = 'scale(1)';
                    setTimeout(() => {
                        elements.player.style.transition = '';
                    }, 500);
                }, 100);
                
                gameLoop();
            } catch (error) {
                console.error('Failed to start game:', error);
                showMenu();
            }
        }

        // Show menu
        function showMenu() {
            gameState.currentState = 'menu';
            gameState.isGameRunning = false;
            
            if (runner) Runner.stop(runner);
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            
            elements.menuScreen.classList.remove('hidden');
            elements.gameOverScreen.classList.add('hidden');
        }

        // Enhanced game loop with professional physics integration
        let lastFrameTime = performance.now();
        
        function gameLoop(currentTime = performance.now()) {
            if (!gameState.isGameRunning) return;
            
            try {
                const deltaTime = currentTime - lastFrameTime;
                lastFrameTime = currentTime;
                
                performanceMonitor.update();
                platformerPhysics.update(deltaTime);
                updateMovement();
                updateCamera();
                updateScore();
                
                gameLoopId = requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error('Game loop error:', error);
                gameOver();
            }
        }

        // Enhanced event listeners
        function setupEventListeners() {
            // Keyboard events with better handling
            document.addEventListener('keydown', (e) => {
                if (gameState.keys[e.code]) return;
                gameState.keys[e.code] = true;
                
                if (gameState.currentState === 'playing') {
                    if (e.code === 'Space' || e.code === 'ArrowUp') {
                        e.preventDefault();
                        jump();
                    }
                }
                
                // Global shortcuts
                if (e.code === 'Escape') {
                    if (gameState.currentState === 'playing') {
                        showMenu();
                    }
                }
            });
            
            document.addEventListener('keyup', (e) => {
                gameState.keys[e.code] = false;
            });
            
            // Enhanced touch events with better jump detection
            document.addEventListener('touchstart', async (e) => {
                if (gameState.currentState === 'playing') {
                    e.preventDefault();
                    gameState.touchStartY = e.touches[0].clientY;
                    await soundEngine.resumeContext();
                    
                    // Store touch as key press for variable jump height
                    gameState.keys['Space'] = true;
                    jump();
                    
                    // Visual feedback for touch
                    elements.player.style.filter = 'brightness(1.3) drop-shadow(0 0 10px var(--primary-color))';
                    setTimeout(() => {
                        elements.player.style.filter = '';
                    }, 200);
                } else if (gameState.currentState === 'menu') {
                    await soundEngine.init();
                }
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                if (gameState.currentState === 'playing') {
                    e.preventDefault();
                    // Release touch for variable jump height
                    gameState.keys['Space'] = false;
                }
            }, { passive: false });
            
            document.addEventListener('touchmove', (e) => {
                if (gameState.currentState === 'playing') {
                    e.preventDefault();
                }
            }, { passive: false });
            
            // Button events
            elements.startButton.addEventListener('click', async () => {
                await soundEngine.init();
                startGame();
            });
            
            elements.restartButton.addEventListener('click', startGame);
            elements.menuButton.addEventListener('click', showMenu);
            
            // Visibility change handling
            document.addEventListener('visibilitychange', () => {
                if (document.hidden && gameState.isGameRunning) {
                    // Pause game when tab is hidden
                    gameState.isGameRunning = false;
                    if (runner) Runner.stop(runner);
                }
            });
            
            // Window resize handling
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    GAME_CONFIG.gameWidth = window.innerWidth;
                    GAME_CONFIG.gameHeight = window.innerHeight;
                    GAME_CONFIG.platformGap = Math.max(100, window.innerHeight * 0.15);
                }, 250);
            });
        }

        // Initialize particles with optimized settings
        function initParticles() {
            try {
                particlesJS('particles-js', {
                    particles: {
                        number: { value: window.innerWidth < 768 ? 40 : 60, density: { enable: true, value_area: 1000 } },
                        color: { value: ["#00d4ff", "#4ecdc4", "#ffffff"] },
                        shape: { type: "circle" },
                        opacity: { value: 0.3, random: true, anim: { enable: true, speed: 0.5 } },
                        size: { value: 2, random: true, anim: { enable: true, speed: 1 } },
                        line_linked: { 
                            enable: true, 
                            distance: 120, 
                            color: "#00d4ff", 
                            opacity: 0.2, 
                            width: 1 
                        },
                        move: { 
                            enable: true, 
                            speed: 0.8, 
                            direction: "none", 
                            random: true, 
                            straight: false, 
                            out_mode: "out" 
                        }
                    },
                    interactivity: {
                        detect_on: "window",
                        events: { 
                            onhover: { enable: true, mode: "repulse" }, 
                            onclick: { enable: false } 
                        },
                        modes: { 
                            repulse: { distance: 80, duration: 0.3 } 
                        }
                    },
                    retina_detect: true
                });
            } catch (error) {
                console.warn('Particles initialization failed:', error);
            }
        }

        // Initialize game
        async function init() {
            try {
                // Show loading screen
                elements.loading.classList.remove('hidden');
                
                // Initialize components
                await new Promise(resolve => setTimeout(resolve, 500)); // Simulate loading
                initPhysics();
                setupEventListeners();
                initParticles();
                
                // Update best score display
                elements.bestScore.textContent = 'Best: ' + gameState.score.best + 'm';
                
                // Hide loading and show menu
                elements.loading.classList.add('hidden');
                gameState.currentState = 'menu';
                showMenu();
                
            } catch (error) {
                console.error('Game initialization failed:', error);
                elements.loading.innerHTML = '<div style="color: var(--danger-color); text-align: center;">Failed to load game.<br><button onclick="location.reload()" style="margin-top: 1rem; padding: 0.5rem 1rem; background: var(--primary-color); border: none; border-radius: 4px; color: white; cursor: pointer;">Retry</button></div>';
            }
        }

        // Start initialization when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // Global error handler
        window.addEventListener('error', (event) => {
            console.error('Global error:', event.error);
        });

        window.addEventListener('unhandledrejection', (event) => {
            console.error('Unhandled promise rejection:', event.reason);
        });
    </script>
</body>
</html>