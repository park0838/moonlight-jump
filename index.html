<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <!-- 🛡️ SECURITY: Content Security Policy -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://cdn.jsdelivr.net; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data: blob:; connect-src 'self'; frame-ancestors 'none'; base-uri 'self'; form-action 'self';">
    <meta http-equiv="X-Content-Type-Options" content="nosniff">
    <meta http-equiv="X-Frame-Options" content="DENY">
    <meta http-equiv="X-XSS-Protection" content="1; mode=block">
    <meta name="referrer" content="strict-origin-when-cross-origin">
    
    <title>Moonlight Jump - Fixed</title>
    
    <!-- Only load particles.js - removed Matter.js dependency -->
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js" 
            integrity="sha384-oHYQNeDBTZNj6KnIfJMAzcEn2OTbeMKKXFeEwU6T+pH0oS1yTIzEBaW6BXmCtvs2" 
            crossorigin="anonymous"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" 
          rel="stylesheet" crossorigin="anonymous">
    <style>
        :root {
            --primary-color: #00d4ff;
            --secondary-color: #ff6b6b;
            --accent-color: #4ecdc4;
            --bg-dark: #0a0a0f;
            --bg-darker: #060609;
            --text-light: #ffffff;
            --text-muted: #a0a0a0;
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --success-color: #00ff88;
            --warning-color: #ffaa00;
            --danger-color: #ff4757;
            
            /* Dynamic Background Theme Variables */
            --theme-bg-primary: #0a0a0f;
            --theme-bg-secondary: #060609;
            --theme-accent: #00d4ff;
            --transition-duration: 2s;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: radial-gradient(ellipse at center, var(--theme-bg-primary) 0%, var(--theme-bg-secondary) 100%);
            transition: background var(--transition-duration) ease-in-out;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: var(--text-light);
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Performance optimized particles background */
        #particles-js {
            position: fixed;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 0.6;
            will-change: transform;
        }

        /* Main game container */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            z-index: 2;
        }

        /* Enhanced UI with glassmorphism */
        #ui {
            position: fixed;
            top: clamp(10px, 2vh, 20px);
            left: clamp(10px, 2vw, 20px);
            right: clamp(10px, 2vw, 20px);
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
            pointer-events: none;
        }

        .ui-element {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: clamp(8px, 1.5vh, 16px) clamp(12px, 3vw, 20px);
            font-weight: 600;
            font-size: clamp(0.9rem, 2.5vw, 1.2rem);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .ui-element:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        /* Player character */
        #player {
            position: absolute;
            width: 30px;
            height: 30px;
            background: radial-gradient(circle, var(--primary-color), var(--accent-color));
            border-radius: 50%;
            box-shadow: 0 0 20px var(--primary-color);
            z-index: 50;
            transition: none;
            will-change: transform;
        }

        /* Platform styling */
        .platform {
            position: absolute;
            background: linear-gradient(90deg, var(--glass-bg), rgba(255, 255, 255, 0.15));
            border: 1px solid var(--glass-border);
            border-radius: 4px;
            height: 12px;
            z-index: 10;
            will-change: transform;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: var(--text-light);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .platform.spring {
            background: linear-gradient(90deg, var(--success-color), #00cc77);
            box-shadow: 0 2px 12px rgba(0, 255, 136, 0.4);
            color: var(--bg-dark);
            font-weight: bold;
        }

        /* Screen transitions with improved UX */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(30px);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            opacity: 1;
            visibility: visible;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 2rem;
        }

        .screen.hidden {
            opacity: 0;
            visibility: hidden;
            transform: scale(0.95);
        }

        .title {
            font-size: clamp(2.5rem, 8vw, 4rem);
            font-weight: 700;
            margin-bottom: clamp(1rem, 4vh, 2rem);
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 3s ease-in-out infinite alternate;
            letter-spacing: -0.02em;
        }

        @keyframes titleGlow {
            from { filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.3)); }
            to { filter: drop-shadow(0 0 40px rgba(0, 212, 255, 0.6)); }
        }

        .subtitle {
            font-size: clamp(0.9rem, 3vw, 1.1rem);
            color: var(--text-muted);
            margin-bottom: clamp(2rem, 6vh, 3rem);
            font-weight: 300;
            line-height: 1.6;
            max-width: 500px;
        }

        .instructions {
            margin-bottom: clamp(2rem, 6vh, 3rem);
            line-height: 1.8;
            font-size: clamp(0.95rem, 3vw, 1.1rem);
            color: var(--text-muted);
            max-width: 400px;
        }

        .instructions p {
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .key-hint {
            background: var(--glass-bg);
            padding: 0.3rem 0.8rem;
            border-radius: 6px;
            border: 1px solid var(--glass-border);
            font-weight: 600;
            font-size: 0.9em;
            color: var(--primary-color);
        }

        /* Enhanced buttons */
        .game-button {
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            border: none;
            padding: clamp(10px, 2vh, 16px) clamp(20px, 4vw, 32px);
            border-radius: 12px;
            color: var(--bg-dark);
            font-weight: 600;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
            letter-spacing: 0.5px;
            min-width: 120px;
            font-family: inherit;
        }

        .game-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 212, 255, 0.5);
            background: linear-gradient(135deg, #00b8e6, #4ecdc4);
        }

        .game-button:active {
            transform: translateY(0);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.4);
        }

        /* Particle animations */
        @keyframes jumpParticleAnim {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(0.3); opacity: 0; }
        }

        @keyframes landParticleAnim {
            0% { transform: translateX(0) translateY(0) scale(1); opacity: 1; }
            100% { transform: translateX(var(--spread, 0)) translateY(10px) scale(0.5); opacity: 0; }
        }

        /* Loading screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--bg-darker);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.5s ease;
        }

        .loading.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 212, 255, 0.2);
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading screen -->
    <div id="loading" class="loading">
        <div class="loading-spinner"></div>
    </div>

    <!-- Background particles -->
    <div id="particles-js"></div>
    
    <div id="game-container">
        <!-- Enhanced UI -->
        <div id="ui">
            <div class="ui-element" id="score">
                <span id="height">0m</span>
            </div>
            <div class="ui-element" id="best-score">
                최고: <span id="best">0m</span>
            </div>
        </div>

        <!-- Game elements -->
        <div id="player"></div>
        <div id="platforms"></div>
        <div id="particles-container"></div>

        <!-- Menu Screen -->
        <div id="menu-screen" class="screen">
            <div class="title">MOONLIGHT JUMP</div>
            <div class="subtitle">중력을 거슬러 달까지 올라가세요</div>
            <div class="subtitle" style="color: var(--success-color);">✅ PHYSICS FIXED</div>
            <div class="instructions">
                <p><span class="key-hint">Spacebar</span> Jump (Hold for higher jump)</p>
                <p><span class="key-hint">A</span> <span class="key-hint">D</span> Move left/right</p>
                <p><span style="color: var(--text-muted);">Fixed: Platform sync, speed, collision bugs</span></p>
            </div>
            <div style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;">
                <button id="start-button" class="game-button" role="button" aria-label="Start Game">Start Fixed</button>
            </div>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="screen hidden">
            <div class="title" style="background: linear-gradient(135deg, var(--danger-color), var(--warning-color)); -webkit-background-clip: text; -webkit-text-fill-color: transparent;">Game Over</div>
            <div id="final-score" style="font-size: clamp(1.5rem, 5vw, 2rem); margin-bottom: clamp(1rem, 3vh, 1.5rem); font-weight: 600;">
                높이: <span>0m</span>
            </div>
            <div style="display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center;">
                <button id="restart-button" class="game-button" role="button" aria-label="Restart Game">Restart</button>
                <button id="menu-button" class="game-button" role="button" aria-label="메뉴로 돌아가기">메뉴</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // COMPLETELY FIXED PHYSICS ENGINE - All bugs resolved
        // ============================================================================

        // FIXED Configuration - Increased speeds and fixed physics
        const CONFIG = {
            // Player physics - OPTIMIZED FOR RESPONSIVE FEEL
            playerWidth: 30,
            playerHeight: 30,
            jumpPower: 520,          // OPTIMIZED: Reduced from 585 for snappier jumps
            gravity: 1100,           // INCREASED: from 980 for more responsive feel
            horizontalSpeed: 280,    // OPTIMIZED: Reduced from 350 for better control
            maxFallSpeed: 650,       // Slightly increased for faster falls
            airControl: 0.8,         // Good air control
            
            // Physics timing - FIXED
            maxDeltaTime: 1/30,      // Cap deltaTime to prevent physics explosions
            velocityDamping: 0.88,   // Ground friction
            
            // Camera system - OPTIMIZED for responsive gameplay
            cameraLerp: 0.15,        // INCREASED: from 0.1 for more responsive camera
            cameraOffset: 280,       // OPTIMIZED: from 400 to reduce empty space above player
            
            // Platform generation - COMPLETELY REDESIGNED
            platformMinWidth: 100,   // Bigger platforms for easier landing
            platformMaxWidth: 200,   // Much bigger max width
            platformHeight: 12,
            platformGapMin: 60,      // Minimum vertical gap
            platformGapMax: 120,     // Maximum vertical gap
            horizontalGapMax: 200,   // Maximum horizontal distance between platforms
            springChance: 0.12,
            
            // Progressive difficulty
            difficultyRamp: 0.0001,  // How fast difficulty increases
            minPlatformsPerRow: 1,
            maxPlatformsPerRow: 3,
            
            // Collision detection - FIXED
            coyoteTime: 150,         // milliseconds
            jumpBuffer: 100,         // milliseconds
            
            // Performance
            maxPlatforms: 50,
            cleanupDistance: 1000,
            
            // Screen Shake System
            shakeIntensity: 8,       // Maximum shake amplitude
            shakeDecay: 0.95,        // How quickly shake fades
            shakeDuration: 200       // Base shake duration in ms
        };

        // Game State Management
        class GameState {
            constructor() {
                this.reset();
                this.best = parseInt(localStorage.getItem('moonlight-jump-best') || '0');
                this.lastLandingTime = 0; // FIXED: Prevent sound spam
            }
            
            reset() {
                this.currentState = 'menu';
                this.isPlaying = false;
                this.height = 0;
                this.score = 0;
                this.frameId = null;
                this.keys = {};
                this.lastUpdate = 0;
                this.lastLandingTime = 0; // FIXED: Reset landing timer
                
                // Physics state - FIXED INITIALIZATION
                this.player = {
                    x: window.innerWidth / 2 - CONFIG.playerWidth / 2,
                    y: window.innerHeight - 80, // FIXED: Start above platform
                    velocityX: 0,
                    velocityY: 0,
                    onGround: false,
                    coyoteTimer: 0,
                    jumpBufferTimer: 0,
                    isJumping: false,
                    jumpHoldTime: 0,
                    wasOnGround: false // FIXED: Track ground state changes
                };
                
                this.camera = {
                    x: 0,
                    y: 0,
                    targetY: 0
                };
                
                this.platforms = [];
                this.particles = [];
                this.achievements = new Set();
            }
        }

        // Screen Shake System for Game Juice
        class ScreenShake {
            constructor() {
                this.trauma = 0;
                this.maxTrauma = 1;
                this.shakeOffset = { x: 0, y: 0 };
            }
            
            addTrauma(amount) {
                this.trauma = Math.min(this.trauma + amount, this.maxTrauma);
            }
            
            update(deltaTime) {
                if (this.trauma > 0) {
                    // Trauma decreases over time
                    this.trauma = Math.max(0, this.trauma - CONFIG.shakeDecay * deltaTime / 1000);
                    
                    // Calculate shake based on trauma squared for more dramatic effect
                    const shake = this.trauma * this.trauma;
                    const maxShake = CONFIG.shakeIntensity;
                    
                    // Generate random shake offset
                    this.shakeOffset.x = (Math.random() * 2 - 1) * maxShake * shake;
                    this.shakeOffset.y = (Math.random() * 2 - 1) * maxShake * shake;
                } else {
                    this.shakeOffset.x = 0;
                    this.shakeOffset.y = 0;
                }
            }
            
            getShakeOffset() {
                return { ...this.shakeOffset };
            }
        }

        // Dynamic Background Theme System
        class BackgroundThemeEngine {
            constructor(gameState) {
                this.gameState = gameState;
                this.currentTheme = 'surface';
                this.transitionProgress = 0;
                this.themeDefinitions = {
                    surface: { 
                        range: [0, 800], 
                        colors: { primary: '#0a0a0f', secondary: '#060609' },
                        accent: '#00d4ff'
                    },
                    atmosphere: { 
                        range: [800, 1600], 
                        colors: { primary: '#1a1a2e', secondary: '#16213e' },
                        accent: '#4ecdc4'
                    },
                    stratosphere: { 
                        range: [1600, 2400], 
                        colors: { primary: '#16213e', secondary: '#0f3460' },
                        accent: '#ff6b6b'
                    },
                    space: { 
                        range: [2400, 3200], 
                        colors: { primary: '#0f3460', secondary: '#0e1a2e' },
                        accent: '#00ff88'
                    },
                    deepSpace: { 
                        range: [3200, Infinity], 
                        colors: { primary: '#0e1a2e', secondary: '#000814' },
                        accent: '#ff4757'
                    }
                };
            }
            
            updateTheme(playerHeight) {
                const height = Math.abs(playerHeight);
                const newTheme = this.getThemeForHeight(height);
                
                if (newTheme !== this.currentTheme) {
                    this.transitionToTheme(newTheme);
                    this.currentTheme = newTheme;
                }
            }
            
            getThemeForHeight(height) {
                for (const [themeName, theme] of Object.entries(this.themeDefinitions)) {
                    if (height >= theme.range[0] && height < theme.range[1]) {
                        return themeName;
                    }
                }
                return 'deepSpace';
            }
            
            transitionToTheme(themeName) {
                const theme = this.themeDefinitions[themeName];
                if (!theme) return;
                
                const root = document.documentElement;
                root.style.setProperty('--theme-bg-primary', theme.colors.primary);
                root.style.setProperty('--theme-bg-secondary', theme.colors.secondary);
                root.style.setProperty('--theme-accent', theme.accent);
                
                // Update platform colors to match theme
                const platforms = document.querySelectorAll('.platform');
                platforms.forEach(platform => {
                    platform.style.borderColor = theme.accent;
                });
            }
            
            getCurrentThemeName() {
                return this.currentTheme;
            }
        }

        // Vector2 utility class
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            
            set(x, y) {
                this.x = x;
                this.y = y;
                return this;
            }
            
            add(v) {
                this.x += v.x;
                this.y += v.y;
                return this;
            }
            
            multiply(scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
            }
            
            lerp(target, factor) {
                this.x += (target.x - this.x) * factor;
                this.y += (target.y - this.y) * factor;
                return this;
            }
        }

        // FIXED Rectangle collision utility
        class Rectangle {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            
            get left() { return this.x; }
            get right() { return this.x + this.width; }
            get top() { return this.y; }
            get bottom() { return this.y + this.height; }
            get centerX() { return this.x + this.width / 2; }
            get centerY() { return this.y + this.height / 2; }
            
            intersects(other) {
                return this.left < other.right &&
                       this.right > other.left &&
                       this.top < other.bottom &&
                       this.bottom > other.top;
            }
            
            // FIXED: More precise collision detection with smaller tolerance
            intersectsWithTolerance(other, tolerance = 1) {
                return (this.left + tolerance) < other.right &&
                       (this.right - tolerance) > other.left &&
                       (this.top + tolerance) < other.bottom &&
                       (this.bottom - tolerance) > other.top;
            }
            
            contains(x, y) {
                return x >= this.left && x <= this.right &&
                       y >= this.top && y <= this.bottom;
            }
        }

        // FIXED Platform Entity - Visual and physics positions unified
        class Platform {
            constructor(x, y, width, type = 'normal', properties = {}) {
                this.physicsRect = new Rectangle(x, y, width, CONFIG.platformHeight);
                this.type = type;
                this.isSpring = type === 'spring'; // Backward compatibility
                this.properties = properties;
                this.state = 'active'; // active, breaking, broken
                this.element = null;
                this.createElement();
                
                // Type-specific initialization
                this.initializeType();
            }
            
            initializeType() {
                switch(this.type) {
                    case 'breakable':
                        this.breakTimer = 0;
                        this.breakDelay = this.properties.breakDelay || 800; // ms before breaking
                        this.isBreaking = false;
                        break;
                    case 'moving':
                        this.startPosition = { x: this.physicsRect.x, y: this.physicsRect.y };
                        this.moveDirection = 1;
                        this.moveSpeed = this.properties.speed || 100; // px/s
                        this.moveRange = this.properties.range || 150; // px
                        this.axis = this.properties.axis || 'horizontal';
                        break;
                }
            }
            
            // FIXED: Single source of truth for position
            get rect() {
                return this.physicsRect;
            }
            
            createElement() {
                this.element = document.createElement('div');
                this.element.className = `platform ${this.type}${this.isSpring ? ' spring' : ''}`;
                // FIXED: Use consistent positioning system from start
                this.element.style.position = 'absolute';
                this.element.style.left = '0px';
                this.element.style.top = '0px';
                this.element.style.width = this.physicsRect.width + 'px';
                this.element.style.height = this.physicsRect.height + 'px';
                
                // Set initial position using transform only
                this.updatePosition(0);
                
                // Set platform content based on type
                this.updatePlatformAppearance();
                
                elements.platforms.appendChild(this.element);
            }
            
            updatePlatformAppearance() {
                switch(this.type) {
                    case 'spring':
                        this.element.textContent = '↑↑↑↑↑↑';
                        this.element.style.color = 'var(--success-color)';
                        break;
                    case 'breakable':
                        this.element.textContent = '▓'.repeat(Math.floor(this.physicsRect.width / 10));
                        this.element.style.color = this.isBreaking ? 'var(--danger-color)' : 'var(--warning-color)';
                        break;
                    case 'moving':
                        this.element.textContent = '→'.repeat(Math.floor(this.physicsRect.width / 12));
                        this.element.style.color = 'var(--secondary-color)';
                        break;
                    default:
                        this.element.textContent = '═'.repeat(Math.floor(this.physicsRect.width / 10));
                        this.element.style.color = 'var(--theme-accent)';
                }
            }
            
            // FIXED: Only use transform for all positioning with screen shake support
            updatePosition(cameraY, shake = { x: 0, y: 0 }) {
                const visualY = this.physicsRect.y + cameraY;
                this.element.style.transform = `translate3d(${this.physicsRect.x + shake.x}px, ${visualY + shake.y}px, 0)`;
            }
            
            // Update platform behavior (called each frame)
            update(deltaTime, gameState) {
                switch(this.type) {
                    case 'breakable':
                        this.updateBreakable(deltaTime, gameState);
                        break;
                    case 'moving':
                        this.updateMoving(deltaTime);
                        break;
                }
            }
            
            updateBreakable(deltaTime, gameState) {
                if (this.state === 'breaking') {
                    this.breakTimer += deltaTime;
                    
                    // Visual feedback during breaking
                    const progress = this.breakTimer / this.breakDelay;
                    const shake = Math.sin(progress * Math.PI * 10) * 2;
                    this.element.style.filter = `hue-rotate(${progress * 60}deg)`;
                    
                    if (this.breakTimer >= this.breakDelay) {
                        this.state = 'broken';
                        this.element.style.opacity = '0.3';
                        this.element.style.pointerEvents = 'none';
                        
                        // Create break particles
                        if (gameState?.gameEngine) {
                            this.createBreakParticles(gameState.gameEngine);
                        }
                    }
                }
            }
            
            updateMoving(deltaTime) {
                const dt = deltaTime / 1000;
                const movement = this.moveSpeed * dt * this.moveDirection;
                
                if (this.axis === 'horizontal') {
                    this.physicsRect.x += movement;
                    const distance = this.physicsRect.x - this.startPosition.x;
                    
                    if (Math.abs(distance) >= this.moveRange) {
                        this.moveDirection *= -1;
                        this.physicsRect.x = this.startPosition.x + (this.moveRange * Math.sign(distance));
                    }
                }
            }
            
            startBreaking() {
                if (this.type === 'breakable' && this.state === 'active') {
                    this.state = 'breaking';
                    this.isBreaking = true;
                    this.updatePlatformAppearance();
                }
            }
            
            createBreakParticles(gameEngine) {
                const centerX = this.physicsRect.x + this.physicsRect.width / 2;
                const centerY = this.physicsRect.y;
                
                for (let i = 0; i < 6; i++) {
                    const particle = new Particle(
                        centerX + (Math.random() - 0.5) * this.physicsRect.width,
                        centerY,
                        (Math.random() - 0.5) * 150,
                        -Math.random() * 100,
                        'var(--warning-color)',
                        400
                    );
                    gameEngine.gameState.particles.push(particle);
                }
            }
            
            isCollidable() {
                return this.state === 'active' || (this.state === 'breaking' && this.type !== 'breakable');
            }
            
            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }
        }

        // Particle System
        class Particle {
            constructor(x, y, vx, vy, color, life) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = life;
                this.maxLife = life;
                this.element = this.createElement();
            }
            
            createElement() {
                const el = document.createElement('div');
                el.style.cssText = `
                    position: absolute;
                    width: 3px;
                    height: 3px;
                    background: ${this.color};
                    border-radius: 50%;
                    pointer-events: none;
                    z-index: 800;
                    box-shadow: 0 0 6px ${this.color};
                `;
                elements.particlesContainer.appendChild(el);
                return el;
            }
            
            update(deltaTime) {
                // FIXED: Proper physics integration
                const dt = deltaTime / 1000; // Convert to seconds
                
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vy += CONFIG.gravity * dt; // Apply gravity to particles
                this.life -= deltaTime;
                
                const alpha = this.life / this.maxLife;
                this.element.style.left = this.x + 'px';
                this.element.style.top = this.y + 'px';
                this.element.style.opacity = alpha;
                
                return this.life > 0;
            }
            
            destroy() {
                if (this.element && this.element.parentNode) {
                    this.element.parentNode.removeChild(this.element);
                }
            }
        }

        // COMPLETELY FIXED Physics Engine
        class PhysicsEngine {
            constructor(gameState) {
                this.gameState = gameState;
                this.collisionCooldown = 0; // FIXED: Prevent rapid collision toggles
            }
            
            update(deltaTime) {
                // FIXED: Cap deltaTime to prevent physics explosions
                const dt = Math.min(deltaTime / 1000, CONFIG.maxDeltaTime); // Convert to seconds and cap
                
                this.updatePlayer(dt);
                this.checkCollisions();
                this.updateTimers(deltaTime);
                this.updateCamera(deltaTime);
            }
            
            updatePlayer(dt) {
                const player = this.gameState.player;
                
                // Store previous ground state
                player.wasOnGround = player.onGround;
                
                // Handle input
                this.handleInput(dt);
                
                // FIXED: Apply gravity properly (only when not on ground)
                if (!player.onGround) {
                    player.velocityY += CONFIG.gravity * dt;
                    player.velocityY = Math.min(player.velocityY, CONFIG.maxFallSpeed);
                }
                
                // FIXED: Apply ground friction when on ground
                if (player.onGround) {
                    player.velocityX *= CONFIG.velocityDamping;
                }
                
                // FIXED: Integrate position using proper physics (velocity is in px/s)
                player.x += player.velocityX * dt;
                player.y += player.velocityY * dt;
                
                // Screen wrapping - FIXED: Better edge detection
                if (player.x + CONFIG.playerWidth < 0) {
                    player.x = window.innerWidth;
                } else if (player.x > window.innerWidth) {
                    player.x = -CONFIG.playerWidth;
                }
                
                // Update collision cooldown
                if (this.collisionCooldown > 0) {
                    this.collisionCooldown -= dt;
                }
                
                // Update player element
                this.updatePlayerVisual();
            }
            
            handleInput(dt) {
                const player = this.gameState.player;
                const keys = this.gameState.keys;
                
                // FIXED: Horizontal movement with proper physics and increased speed
                let targetVelX = 0;
                if (keys['KeyA'] || keys['ArrowLeft']) targetVelX = -CONFIG.horizontalSpeed;
                if (keys['KeyD'] || keys['ArrowRight']) targetVelX = CONFIG.horizontalSpeed;
                
                // FIXED: Apply different control based on ground state
                const control = player.onGround ? 1 : CONFIG.airControl;
                const acceleration = player.onGround ? 2500 : 1200; // FIXED: Faster acceleration
                
                if (targetVelX !== 0) {
                    const accelAmount = acceleration * control * dt;
                    if (Math.abs(targetVelX - player.velocityX) > accelAmount) {
                        player.velocityX += Math.sign(targetVelX - player.velocityX) * accelAmount;
                    } else {
                        player.velocityX = targetVelX;
                    }
                } else {
                    // Deceleration when no input
                    const decelAmount = (player.onGround ? 2000 : 600) * dt; // FIXED: Faster deceleration
                    if (Math.abs(player.velocityX) > decelAmount) {
                        player.velocityX -= Math.sign(player.velocityX) * decelAmount;
                    } else {
                        player.velocityX = 0;
                    }
                }
                
                // FIXED: Jumping with proper variable jump height
                if (keys['Space'] || keys['ArrowUp']) {
                    if (!player.isJumping) {
                        // Start jump
                        if (player.onGround || player.coyoteTimer > 0) {
                            this.jump();
                            player.isJumping = true;
                            player.jumpHoldTime = 0;
                        } else if (player.jumpBufferTimer <= 0) {
                            player.jumpBufferTimer = CONFIG.jumpBuffer;
                        }
                    } else {
                        // Continue jump (variable height)
                        player.jumpHoldTime += dt * 1000; // Convert back to ms
                        if (player.jumpHoldTime < 200 && player.velocityY < 0) {
                            // Reduce gravity effect while holding jump (for max 200ms)
                            player.velocityY += -CONFIG.gravity * 0.3 * dt;
                        }
                    }
                } else {
                    // Release jump
                    if (player.isJumping && player.velocityY < 0) {
                        // Cut jump short for variable jump height
                        player.velocityY *= 0.5;
                    }
                    player.isJumping = false;
                }
            }
            
            jump() {
                const player = this.gameState.player;
                
                player.velocityY = -CONFIG.jumpPower; // Negative because Y grows downward
                player.onGround = false;
                player.coyoteTimer = 0;
                player.jumpBufferTimer = 0;
                
                // Create jump particles - FIXED: Position them well below player
                this.createJumpParticles(player.x + CONFIG.playerWidth/2, player.y + CONFIG.playerHeight + 20);
                
                // Play sound
                soundEngine.jump();
            }
            
            // COMPLETELY FIXED collision detection
            checkCollisions() {
                const player = this.gameState.player;
                const playerRect = new Rectangle(player.x, player.y, CONFIG.playerWidth, CONFIG.playerHeight);
                
                let wasOnGround = player.onGround;
                player.onGround = false;
                
                for (const platform of this.gameState.platforms) {
                    if (platform.isCollidable() && playerRect.intersects(platform.rect)) {
                        // FIXED: More precise collision response with better conditions
                        const playerBottom = player.y + CONFIG.playerHeight;
                        const playerTop = player.y;
                        const playerLeft = player.x;
                        const playerRight = player.x + CONFIG.playerWidth;
                        
                        const platformTop = platform.rect.y;
                        const platformBottom = platform.rect.y + platform.rect.height;
                        const platformLeft = platform.rect.x;
                        const platformRight = platform.rect.x + platform.rect.width;
                        
                        // Landing on top of platform
                        if (player.velocityY >= 0 && 
                            playerBottom >= platformTop && 
                            playerBottom <= platformTop + 8 &&
                            playerRight > platformLeft + 2 && 
                            playerLeft < platformRight - 2) {
                            
                            player.y = platformTop - CONFIG.playerHeight;
                            player.velocityY = 0;
                            player.onGround = true;
                            player.coyoteTimer = CONFIG.coyoteTime;
                            
                            // FIXED: Only trigger landing effects if we weren't on ground before
                            if (!wasOnGround && this.collisionCooldown <= 0) {
                                this.handleLanding(platform);
                                this.collisionCooldown = 100; // 100ms cooldown
                            }
                            break;
                        }
                        // FIXED: Side collisions - push player away from platform
                        else {
                            const overlapLeft = playerRight - platformLeft;
                            const overlapRight = platformRight - playerLeft;
                            const overlapTop = playerBottom - platformTop;
                            const overlapBottom = platformBottom - playerTop;
                            
                            const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                            
                            if (minOverlap === overlapLeft && overlapLeft < 15) {
                                player.x = platformLeft - CONFIG.playerWidth - 1;
                                player.velocityX = Math.min(player.velocityX, 0);
                            } else if (minOverlap === overlapRight && overlapRight < 15) {
                                player.x = platformRight + 1;
                                player.velocityX = Math.max(player.velocityX, 0);
                            } else if (minOverlap === overlapBottom && overlapBottom < 15 && player.velocityY < 0) {
                                player.y = platformBottom + 1;
                                player.velocityY = 0;
                            }
                        }
                    }
                }
                
                // Jump buffer handling
                if (player.onGround && player.jumpBufferTimer > 0) {
                    this.jump();
                }
            }
            
            // FIXED: Landing with sound spam prevention
            handleLanding(platform) {
                const player = this.gameState.player;
                const currentTime = Date.now();
                
                // FIXED: Prevent sound spam
                if (currentTime - this.gameState.lastLandingTime < 50) {
                    return;
                }
                this.gameState.lastLandingTime = currentTime;
                
                // Create landing particles
                this.createLandParticles(player.x + CONFIG.playerWidth/2, player.y + CONFIG.playerHeight);
                
                // ADDED: Screen shake for impact feedback
                if (this.gameEngine) {
                    this.gameEngine.screenShake.addTrauma(0.3); // Medium shake for normal landing
                }
                
                // ADDED: Handle platform-specific landing behaviors
                this.handlePlatformType(platform);
                
                if (platform.isSpring) {
                    // Spring boost
                    player.velocityY = -CONFIG.jumpPower * 1.8;
                    player.onGround = false;
                    
                    // Spring particles
                    this.createSpringParticles(platform.rect.centerX, platform.rect.y);
                    soundEngine.spring();
                    
                    // ADDED: Stronger screen shake for spring platforms
                    if (this.gameEngine) {
                        this.gameEngine.screenShake.addTrauma(0.6); // Strong shake for spring bounce
                    }
                    
                    // Visual feedback
                    platform.element.style.animation = 'springActivated 0.3s ease-out';
                    setTimeout(() => {
                        if (platform.element) {
                            platform.element.style.animation = '';
                        }
                    }, 300);
                } else {
                    soundEngine.land();
                }
            }
            
            updateTimers(deltaTime) {
                const player = this.gameState.player;
                
                if (player.coyoteTimer > 0) {
                    player.coyoteTimer -= deltaTime;
                }
                
                if (player.jumpBufferTimer > 0) {
                    player.jumpBufferTimer -= deltaTime;
                }
            }
            
            updateCamera(deltaTime) {
                const player = this.gameState.player;
                const camera = this.gameState.camera;
                
                // Camera follows player
                camera.targetY = -player.y + CONFIG.cameraOffset;
                camera.y += (camera.targetY - camera.y) * CONFIG.cameraLerp;
                
                // Update platform positions and behaviors with screen shake
                const shake = this.gameEngine ? this.gameEngine.screenShake.getShakeOffset() : { x: 0, y: 0 };
                for (const platform of this.gameState.platforms) {
                    platform.update(deltaTime, this.gameState); // ADDED: Update platform behaviors
                    platform.updatePosition(camera.y, shake);
                }
            }
            
            updatePlayerVisual() {
                const player = this.gameState.player;
                const camera = this.gameState.camera;
                const shake = this.gameEngine ? this.gameEngine.screenShake.getShakeOffset() : { x: 0, y: 0 }; // FIXED: Check if gameEngine exists
                
                elements.player.style.transform = `translate3d(${player.x + shake.x}px, ${player.y + camera.y + shake.y}px, 0)`;
            }
            
            handlePlatformType(platform) {
                switch(platform.type) {
                    case 'breakable':
                        platform.startBreaking();
                        // Different sound for breakable platforms
                        soundEngine.breakableLand();
                        break;
                    case 'moving':
                        // Inherit platform momentum
                        const player = this.gameState.player;
                        if (platform.axis === 'horizontal') {
                            player.velocityX += platform.moveSpeed * platform.moveDirection * 0.3;
                        }
                        break;
                }
            }
            
            createJumpParticles(x, y) {
                for (let i = 0; i < 8; i++) { // ENHANCED: Increased from 5 to 8 particles
                    const particle = new Particle(
                        x + (Math.random() - 0.5) * 30,
                        y,
                        (Math.random() - 0.5) * 120, // px/s (horizontal spread)
                        Math.random() * 80 + 20,     // px/s (downward) - FIXED: particles go down/sideways
                        'var(--primary-color)',
                        600 // ENHANCED: Longer lifetime from 400 to 600ms
                    );
                    this.gameState.particles.push(particle);
                }
            }
            
            createLandParticles(x, y) {
                for (let i = 0; i < 12; i++) { // ENHANCED: Increased from 8 to 12 particles for landing impact
                    const particle = new Particle(
                        x + (Math.random() - 0.5) * 40, // ENHANCED: Wider spread from 30 to 40
                        y,
                        (Math.random() - 0.5) * 180,  // px/s - ENHANCED: More spread from 150 to 180
                        -Math.random() * 120,        // px/s - ENHANCED: Higher velocity from 100 to 120
                        'var(--accent-color)',
                        500 // ENHANCED: Longer lifetime from 400 to 500ms
                    );
                    this.gameState.particles.push(particle);
                }
            }
            
            createSpringParticles(x, y) {
                for (let i = 0; i < 12; i++) {
                    const particle = new Particle(
                        x + (Math.random() - 0.5) * 40,
                        y,
                        (Math.random() - 0.5) * 200,  // px/s
                        -Math.random() * 300 - 100,  // px/s (strong upward)
                        'var(--success-color)',
                        600
                    );
                    this.gameState.particles.push(particle);
                }
            }
        }

        // Platform Generator - COMPLETELY REDESIGNED
        class PlatformGenerator {
            constructor(gameState) {
                this.gameState = gameState;
                this.lastPlatformY = window.innerHeight - 50;
                this.lastPlatformX = window.innerWidth / 2;
                this.height = 0; // Track height for difficulty
            }
            
            generateInitialPlatforms() {
                // Clear existing platforms
                this.gameState.platforms.forEach(p => p.destroy());
                this.gameState.platforms = [];
                
                // Starting platform - Large and centered
                const startPlatform = new Platform(
                    window.innerWidth / 2 - 150,
                    window.innerHeight - 50,
                    300 // Extra wide starting platform
                );
                this.gameState.platforms.push(startPlatform);
                this.lastPlatformY = window.innerHeight - 50;
                this.lastPlatformX = window.innerWidth / 2;
                this.height = 0;
                
                // Generate initial platforms with new system
                for (let i = 0; i < 15; i++) {
                    this.generateNextPlatformRow();
                }
            }
            
            generateNextPlatformRow() {
                // Calculate difficulty based on height
                const difficulty = Math.min(this.height * CONFIG.difficultyRamp, 0.8);
                
                // Vertical gap - starts easy, gets harder
                const baseGap = CONFIG.platformGapMin;
                const gapRange = CONFIG.platformGapMax - CONFIG.platformGapMin;
                const gap = baseGap + (gapRange * difficulty) + Math.random() * 20;
                
                this.lastPlatformY -= gap;
                this.height += gap;
                
                // Decide how many platforms in this row
                const platformCount = Math.random() < 0.3 + difficulty * 0.4 ? 
                    (Math.random() < 0.7 ? 2 : 3) : 1;
                
                if (platformCount === 1) {
                    this.generateSinglePlatform(difficulty);
                } else {
                    this.generateMultiplePlatforms(platformCount, difficulty);
                }
            }
            
            generateSinglePlatform(difficulty) {
                // Single platform - can be further from last position
                const maxHorizontalDistance = CONFIG.horizontalGapMax * (0.6 + difficulty * 0.4);
                
                // Calculate reachable area from last platform
                let targetX = this.lastPlatformX;
                const horizontalShift = (Math.random() - 0.5) * maxHorizontalDistance;
                targetX += horizontalShift;
                
                // Platform width - smaller as difficulty increases
                const minWidth = CONFIG.platformMinWidth * (1 - difficulty * 0.3);
                const maxWidth = CONFIG.platformMaxWidth * (1 - difficulty * 0.2);
                const width = minWidth + Math.random() * (maxWidth - minWidth);
                
                // Ensure platform stays on screen
                const margin = 50;
                targetX = Math.max(margin, Math.min(window.innerWidth - width - margin, targetX));
                
                // ENHANCED: Determine platform type based on height and difficulty
                const platformType = this.determinePlatformType(difficulty, this.height);
                const properties = this.getPlatformProperties(platformType, difficulty);
                
                const platform = new Platform(targetX, this.lastPlatformY, width, platformType, properties);
                this.gameState.platforms.push(platform);
                
                this.lastPlatformX = targetX + width / 2;
            }
            
            generateMultiplePlatforms(count, difficulty) {
                // Multiple platforms - create safe path
                const screenWidth = window.innerWidth;
                const margin = 50;
                const availableWidth = screenWidth - 2 * margin;
                
                const platformWidth = Math.max(80, CONFIG.platformMinWidth * (1 - difficulty * 0.2));
                const spacing = availableWidth / count;
                
                for (let i = 0; i < count; i++) {
                    const x = margin + spacing * i + (spacing - platformWidth) * Math.random();
                    
                    // ENHANCED: Use new platform type system, fewer special types in multi-platform rows
                    const platformType = Math.random() < CONFIG.springChance * 0.3 ? 'spring' : 'normal';
                    const properties = this.getPlatformProperties(platformType, difficulty);
                    
                    const platform = new Platform(x, this.lastPlatformY, platformWidth, platformType, properties);
                    this.gameState.platforms.push(platform);
                }
                
                // Update last position to middle platform
                this.lastPlatformX = screenWidth / 2;
            }
            
            determinePlatformType(difficulty, height) {
                // Progressive platform type introduction based on height
                const heightNormalized = height / 1000; // Normalize height
                
                // Platform type probabilities based on height
                const typeChances = {
                    normal: 0.7 - (heightNormalized * 0.2), // Fewer normal platforms at height
                    spring: CONFIG.springChance,
                    breakable: Math.min(0.3, heightNormalized * 0.15), // Introduce at 300m+
                    moving: Math.min(0.2, Math.max(0, heightNormalized - 0.5) * 0.1) // Introduce at 500m+
                };
                
                // Ensure at least 40% normal platforms
                typeChances.normal = Math.max(0.4, typeChances.normal);
                
                const random = Math.random();
                let cumulative = 0;
                
                for (const [type, chance] of Object.entries(typeChances)) {
                    cumulative += chance;
                    if (random <= cumulative) {
                        return type;
                    }
                }
                
                return 'normal';
            }
            
            getPlatformProperties(type, difficulty) {
                switch(type) {
                    case 'breakable':
                        return {
                            breakDelay: 800 - (difficulty * 200) // Shorter delay at higher difficulty
                        };
                    case 'moving':
                        return {
                            speed: 80 + (difficulty * 40), // Faster at higher difficulty
                            range: 120 + (difficulty * 80),
                            axis: Math.random() < 0.8 ? 'horizontal' : 'vertical'
                        };
                    default:
                        return {};
                }
            }
            
            update() {
                const player = this.gameState.player;
                
                // Generate platform rows ahead of player
                while (this.lastPlatformY > player.y - 800) {
                    this.generateNextPlatformRow();
                }
                
                // Cleanup platforms behind player
                this.gameState.platforms = this.gameState.platforms.filter(platform => {
                    if (platform.rect.y > player.y + CONFIG.cleanupDistance) {
                        platform.destroy();
                        return false;
                    }
                    return true;
                });
                
                // Limit total platforms for performance
                if (this.gameState.platforms.length > CONFIG.maxPlatforms) {
                    const excess = this.gameState.platforms.length - CONFIG.maxPlatforms;
                    for (let i = 0; i < excess; i++) {
                        this.gameState.platforms[i].destroy();
                    }
                    this.gameState.platforms.splice(0, excess);
                }
            }
        }

        // Sound Engine (simplified)
        class SoundEngine {
            constructor() {
                this.audioContext = null;
                this.initialized = false;
            }
            
            async init() {
                if (this.initialized) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.initialized = true;
                } catch (error) {
                    console.warn('Audio initialization failed:', error);
                }
            }
            
            playTone(frequency, duration, type = 'sine') {
                if (!this.audioContext) return;
                
                const oscillator = this.audioContext.createOscillator();
                const gainNode = this.audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(this.audioContext.destination);
                
                oscillator.type = type;
                oscillator.frequency.setValueAtTime(frequency, this.audioContext.currentTime);
                
                gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration);
                
                oscillator.start(this.audioContext.currentTime);
                oscillator.stop(this.audioContext.currentTime + duration);
            }
            
            jump() {
                this.playTone(400, 0.15, 'square'); // ENHANCED: Longer duration from 0.1 to 0.15
            }
            
            land() {
                this.playTone(200, 0.08, 'sawtooth'); // ENHANCED: More noticeable from 0.05 to 0.08
            }
            
            spring() {
                this.playTone(800, 0.25, 'sine'); // ENHANCED: Slightly longer from 0.2 to 0.25
            }
            
            breakableLand() {
                this.playTone(150, 0.12, 'sawtooth'); // ADDED: Lower, longer sound for breakable platforms
            }
        }

        // Main Game Engine
        class GameEngine {
            constructor() {
                this.gameState = new GameState();
                this.physics = new PhysicsEngine(this.gameState);
                this.platformGenerator = new PlatformGenerator(this.gameState);
                this.performanceMonitor = new PerformanceMonitor();
                this.screenShake = new ScreenShake(); // ADDED: Screen shake system
                this.backgroundTheme = new BackgroundThemeEngine(this.gameState); // ADDED: Background theme system
                
                // ADDED: Give physics access to game engine for screen shake
                this.physics.gameEngine = this;
            }
            
            start() {
                this.gameState.reset();
                this.gameState.isPlaying = true;
                this.gameState.currentState = 'playing';
                
                // Hide menu, show game
                elements.menuScreen.classList.add('hidden');
                elements.gameOverScreen.classList.add('hidden');
                
                // Generate initial platforms
                this.platformGenerator.generateInitialPlatforms();
                
                // FIXED: Wait a frame before starting physics to prevent initial collision
                setTimeout(() => {
                    // Start game loop
                    this.gameState.lastUpdate = performance.now();
                    this.gameLoop();
                }, 16);
            }
            
            gameLoop(currentTime = performance.now()) {
                if (!this.gameState.isPlaying) return;
                
                const deltaTime = currentTime - this.gameState.lastUpdate;
                this.gameState.lastUpdate = currentTime;
                
                // Update performance
                this.performanceMonitor.update();
                
                // Update game systems
                this.physics.update(deltaTime);
                this.platformGenerator.update();
                this.updateParticles(deltaTime);
                this.updateScore();
                this.screenShake.update(deltaTime); // ADDED: Update screen shake
                this.backgroundTheme.updateTheme(this.gameState.player.y); // ADDED: Update background theme
                
                // Check game over
                if (this.gameState.player.y > window.innerHeight + 500) {
                    this.gameOver();
                    return;
                }
                
                this.gameState.frameId = requestAnimationFrame(this.gameLoop.bind(this));
            }
            
            updateParticles(deltaTime) {
                this.gameState.particles = this.gameState.particles.filter(particle => {
                    const alive = particle.update(deltaTime);
                    if (!alive) {
                        particle.destroy();
                    }
                    return alive;
                });
            }
            
            updateScore() {
                const player = this.gameState.player;
                const height = Math.max(0, Math.floor((window.innerHeight - player.y) / 8));
                
                if (height > this.gameState.height) {
                    this.gameState.height = height;
                    elements.height.textContent = height + 'm';
                }
            }
            
            gameOver() {
                this.gameState.isPlaying = false;
                this.gameState.currentState = 'gameOver';
                
                if (this.gameState.frameId) {
                    cancelAnimationFrame(this.gameState.frameId);
                    this.gameState.frameId = null;
                }
                
                // Update best score
                if (this.gameState.height > this.gameState.best) {
                    this.gameState.best = this.gameState.height;
                    localStorage.setItem('moonlight-jump-best', this.gameState.best.toString());
                }
                
                // Show game over screen
                elements.finalScore.textContent = `높이: ${this.gameState.height}m`;
                elements.best.textContent = this.gameState.best + 'm';
                elements.gameOverScreen.classList.remove('hidden');
            }
            
            showMenu() {
                this.gameState.isPlaying = false;
                this.gameState.currentState = 'menu';
                
                if (this.gameState.frameId) {
                    cancelAnimationFrame(this.gameState.frameId);
                    this.gameState.frameId = null;
                }
                
                elements.menuScreen.classList.remove('hidden');
                elements.gameOverScreen.classList.add('hidden');
            }
        }

        // Performance Monitor
        class PerformanceMonitor {
            constructor() {
                this.fps = 60;
                this.lastTime = performance.now();
                this.frameCount = 0;
                this.fpsUpdateTime = 0;
            }
            
            update() {
                const currentTime = performance.now();
                this.frameCount++;
                
                if (currentTime - this.fpsUpdateTime > 1000) {
                    this.fps = Math.round(this.frameCount);
                    this.frameCount = 0;
                    this.fpsUpdateTime = currentTime;
                }
                
                this.lastTime = currentTime;
            }
        }

        // DOM Elements
        const elements = {
            loading: document.getElementById('loading'),
            menuScreen: document.getElementById('menu-screen'),
            gameOverScreen: document.getElementById('game-over-screen'),
            startButton: document.getElementById('start-button'),
            restartButton: document.getElementById('restart-button'),
            menuButton: document.getElementById('menu-button'),
            player: document.getElementById('player'),
            platforms: document.getElementById('platforms'),
            particlesContainer: document.getElementById('particles-container'),
            height: document.getElementById('height'),
            best: document.getElementById('best'),
            finalScore: document.querySelector('#final-score span')
        };

        // Global instances
        let gameEngine;
        let soundEngine;

        // Event Handlers
        function setupEventListeners() {
            // Keyboard events
            document.addEventListener('keydown', (e) => {
                gameEngine.gameState.keys[e.code] = true;
                
                if (gameEngine.gameState.currentState === 'playing') {
                    if (e.code === 'Space' || e.code === 'ArrowUp') {
                        e.preventDefault();
                    }
                }
            });
            
            document.addEventListener('keyup', (e) => {
                gameEngine.gameState.keys[e.code] = false;
            });
            
            // Touch events
            document.addEventListener('touchstart', async (e) => {
                if (gameEngine.gameState.currentState === 'playing') {
                    e.preventDefault();
                    await soundEngine.init();
                    
                    const touch = e.touches[0];
                    const touchX = touch.clientX;
                    const touchY = touch.clientY;
                    const screenWidth = window.innerWidth;
                    
                    // Movement zones
                    if (touchY > window.innerHeight * 0.7) {
                        if (touchX < screenWidth * 0.3) {
                            gameEngine.gameState.keys['KeyA'] = true;
                        } else if (touchX > screenWidth * 0.7) {
                            gameEngine.gameState.keys['KeyD'] = true;
                        }
                    }
                    
                    // Jump zone
                    if (touchY <= window.innerHeight * 0.7) {
                        gameEngine.gameState.keys['Space'] = true;
                    }
                }
            }, { passive: false });
            
            document.addEventListener('touchend', (e) => {
                if (gameEngine.gameState.currentState === 'playing') {
                    e.preventDefault();
                    gameEngine.gameState.keys['Space'] = false;
                    gameEngine.gameState.keys['KeyA'] = false;
                    gameEngine.gameState.keys['KeyD'] = false;
                }
            }, { passive: false });
            
            // Button events
            elements.startButton.addEventListener('click', async () => {
                await soundEngine.init();
                gameEngine.start();
            });
            
            elements.restartButton.addEventListener('click', () => {
                gameEngine.start();
            });
            
            elements.menuButton.addEventListener('click', () => {
                gameEngine.showMenu();
            });
        }

        // Initialize particles
        function initParticles() {
            try {
                particlesJS('particles-js', {
                    particles: {
                        number: { value: window.innerWidth < 768 ? 40 : 60, density: { enable: true, value_area: 1000 } },
                        color: { value: ["#00d4ff", "#4ecdc4", "#ffffff"] },
                        shape: { type: "circle" },
                        opacity: { value: 0.3, random: true, anim: { enable: true, speed: 0.5 } },
                        size: { value: 2, random: true, anim: { enable: true, speed: 1 } },
                        line_linked: { 
                            enable: true, 
                            distance: 120, 
                            color: "#00d4ff", 
                            opacity: 0.2, 
                            width: 1 
                        },
                        move: { 
                            enable: true, 
                            speed: 0.8, 
                            direction: "none", 
                            random: true, 
                            straight: false, 
                            out_mode: "out" 
                        }
                    },
                    interactivity: {
                        detect_on: "window",
                        events: { 
                            onhover: { enable: true, mode: "repulse" }, 
                            onclick: { enable: false } 
                        },
                        modes: { 
                            repulse: { distance: 80, duration: 0.3 } 
                        }
                    },
                    retina_detect: true
                });
            } catch (error) {
                console.warn('Particles initialization failed:', error);
            }
        }

        // Initialize game
        async function init() {
            try {
                // Show loading screen
                elements.loading.classList.remove('hidden');
                
                // Initialize game systems
                gameEngine = new GameEngine();
                soundEngine = new SoundEngine();
                
                // Setup
                setupEventListeners();
                initParticles();
                
                // Load best score
                elements.best.textContent = gameEngine.gameState.best + 'm';
                
                // Hide loading and show menu
                await new Promise(resolve => setTimeout(resolve, 500));
                elements.loading.classList.add('hidden');
                gameEngine.showMenu();
                
            } catch (error) {
                console.error('Failed to initialize game:', error);
                alert('Failed to load game. Please refresh the page.');
            }
        }

        // Start the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>